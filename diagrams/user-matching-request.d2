# User Matching Request Flow
# Direction: Down indicates the typical flow of requests and data
direction: down

# Define styles for different component types
styles: {
  user: { shape: person; style.fill: "#f5f5f5" }
  ui: { shape: rectangle; style: { fill: "#e1f5fe"; stroke: "#0277bd"; border-radius: 5 } }
  backend: { shape: rectangle; style: { fill: "#fffde7"; stroke: "#fbc02d"; border-radius: 5 } }
  qdrant_client: { shape: hexagon; style: { fill: "#e8f5e9"; stroke: "#388e3c" } }
  qdrant_db: { shape: cylinder; style.fill: "#fff3e0" }
  logic: { shape: rectangle; style: { fill: "#fce4ec"; stroke: "#d81b60"; border-radius: 5; stroke-dash: 4 } }
  results: { shape: cloud; style.fill: "#d1c4e9" }
  note: { shape: text }
}

# Define main components
User: { class: user; label: "User" }
WebAppUI: { class: ui; label: "Web App UI" }
BackendAPI: { class: backend; label: "Backend API" }
QdrantClient: { class: qdrant_client; label: "Qdrant Client" }
QdrantDB: { class: qdrant_db; label: "Qdrant Collection\n(Users + Vectors)" }
MatchingLogic: { class: logic; label: "Weighted Score Calculation\n(Client-Side)" }
TopNMatches: { class: results; label: "Top N Matches" }

# --- Main Flow ---

User -> WebAppUI: "Selects Match Criteria\n(Overall/Goals/Hobbies) & N"
WebAppUI -> BackendAPI: "Request Top N Matches\nCriteria: X"

# --- Branching based on Criteria (Illustrated Conceptually) ---

# Branch 1: Simple Overall Match
BackendAPI -> QdrantClient: "'Overall' Search" {
  label: "If Criteria == Overall"
  style.stroke-dash: 5
}
QdrantClient -> QdrantDB: "Search Top N\nby 'general_vector'"
QdrantDB -> QdrantClient: "Top N Results (by General)"
QdrantClient -> BackendAPI: "Pass Results"
BackendAPI -> TopNMatches: "Format Results"

# Branch 2: Weighted Goals/Hobbies Match (Detailed Technical Flow)
WeightedSearchFlow: {
  label: |md
    ### Weighted Search (Goals/Hobbies)
    (If Criteria == Goals or Hobbies)
  |
  style.stroke-dash: 3

  BackendAPI -> QdrantClient.Search1: "1. Search Primary Vector"
  QdrantClient.Search1: { extends: QdrantClient; label: "Qdrant Client\n(Search 1)" }
  QdrantClient.Search1 -> QdrantDB: "Search Top M (e.g., 50)\nby 'goals/hobbies_vector'"
  QdrantDB -> QdrantClient.Search1: "Top M Primary Results"
  QdrantClient.Search1 -> MatchingLogic: "Primary Scores (Goals/Hobbies)"

  BackendAPI -> QdrantClient.Search2: "2. Search General Vector"
  QdrantClient.Search2: { extends: QdrantClient; label: "Qdrant Client\n(Search 2)" }
  QdrantClient.Search2 -> QdrantDB: "Search Top M (e.g., 50)\nby 'general_vector'"
  QdrantDB -> QdrantClient.Search2: "Top M General Results"
  QdrantClient.Search2 -> MatchingLogic: "General Scores"

  MatchingLogic -> BackendAPI: "3. Merge, Weight, Sort -> Final Top N"
  BackendAPI -> TopNMatches: "Format Results"

}

# --- Final Step ---
TopNMatches -> WebAppUI: "Display Matches"

# --- Explanatory Note for Weighted Search ---
WeightedSearchNote: {
  class: note
  label: |md
    **Weighted Search Explanation (Goals/Hobbies):**
    1.  Perform **two** separate searches in Qdrant:
        - One using the primary vector (`goals_vector` or `hobbies_vector`).
        - One using the `general_vector`.
        *(Fetch more results than N, e.g., M=50)*
    2.  Combine results in the backend (`MatchingLogic`).
    3.  Calculate a weighted score for each unique user:
        `final = (w1 * primary_score) + (w2 * general_score)`
    4.  Sort users by the `final_score` and return the Top N.
  |
}
WeightedSearchFlow -> WeightedSearchNote: "Explanation" { style.stroke-dash: 2 } 