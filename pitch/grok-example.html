<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Social Graph</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle, #1a1a2e, #0f0f23);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 

100vh;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <canvas id="graphCanvas"></canvas>
    <div id="tooltip" class="tooltip" style="display: none;"></div>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const tooltip = document.getElementById('tooltip');

        // Set canvas size
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Graph data
        const nodes = [
            { id: 0, name: 'Alice', x: 0, y: 0, z: 0 },
            { id: 1, name: 'Bob', x: 0, y: 0, z: 0 },
            { id: 2, name: 'Charlie', x: 0, y: 0, z: 0 },
            { id: 3, name: 'Diana', x: 0, y: 0, z: 0 },
            { id: 4, name: 'Eve', x: 0, y: 0, z: 0 }
        ];

        const edges = [
            { source: 0, target: 1, strength: 0.8 },
            { source: 0, target: 2, strength: 0.4 },
            { source: 0, target: 3, strength: 0.6 },
            { source: 1, target: 2, strength: 0.7 },
            { source: 1, target: 4, strength: 0.5 },
            { source: 2, target: 3, strength: 0.3 },
            { source: 3, target: 4, strength: 0.9 },
            { source: 4, target: 0, strength: 0.2 }
        ];

        // Initialize node positions in 3D space using spherical coordinates
        const radius = 150;
        nodes.forEach((node, i) => {
            const theta = Math.acos(2 * Math.random() - 1); // Polar angle
            const phi = 2 * Math.PI * Math.random(); // Azimuthal angle
            const r = radius * Math.cbrt(Math.random()); // Radial distance (cube root for uniform distribution)
            node.x = r * Math.sin(theta) * Math.cos(phi);
            node.y = r * Math.sin(theta) * Math.sin(phi);
            node.z = r * Math.cos(theta);
        });

        // Camera settings
        const fov = 800;
        let rotation = 0;
        let selectedNode = null;

        // Project 3D point to 2D
        function project(x, y, z) {
            const factor = fov / (fov + z);
            return {
                x: x * factor + canvas.width / 2,
                y: y * factor + canvas.height / 2,
                scale: factor
            };
        }

        // Rotate point around Y-axis
        function rotateY(x, z, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: x * cos + z * sin,
                z: -x * sin + z * cos
            };
        }

        // Draw the graph
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Transform and project nodes
            const transformedNodes = nodes.map(node => {
                const rotated = rotateY(node.x, node.z, rotation);
                const proj = project(rotated.x, node.y, rotated.z + 300);
                return { ...node, ...proj, z: rotated.z };
            });

            // Sort by z for correct rendering order
            transformedNodes.sort((a, b) => b.z - a.z);

            // Draw edges
            edges.forEach(edge => {
                const source = transformedNodes[edge.source];
                const target = transformedNodes[edge.target];
                const isHighlighted = selectedNode !== null && 
                    (edge.source === selectedNode || edge.target === selectedNode);

                ctx.beginPath();
                ctx.moveTo(source.x, source.y);
                ctx.lineTo(target.x, target.y);
                ctx.strokeStyle = isHighlighted ? '#ffcc00' : 'rgba(100, 150, 255, 0.6)';
                ctx.lineWidth = edge.strength * 5 * (isHighlighted ? 1.5 : 1);
                ctx.stroke();
            });

            // Draw nodes
            transformedNodes.forEach(node => {
                const isHighlighted = selectedNode === node.id;
                ctx.beginPath();
                ctx.arc(node.x, node.y, 10 * node.scale, 0, 2 * Math.PI);
                ctx.fillStyle = isHighlighted ? '#ffcc00' : '#4a90e2';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw name
                ctx.font = `${12 * node.scale}px Arial`;
                ctx.fillStyle = '#fff';
                ctx.textAlign = 'center';
                ctx.fillText(node.name, node.x, node.y + 20 * node.scale);
            });
        }

        // Animation loop
        function animate() {
            rotation += 0.01;
            draw();
            requestAnimationFrame(animate);
        }

        // Handle click
        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let closestNode = null;
            let minDist = Infinity;

            nodes.forEach((node, i) => {
                const rotated = rotateY(node.x, node.z, rotation);
                const proj = project(rotated.x, node.y, rotated.z + 300);
                const dist = Math.sqrt((mouseX - proj.x) ** 2 + (mouseY - proj.y) ** 2);
                if (dist < minDist && dist < 20 * proj.scale) {
                    minDist = dist;
                    closestNode = i;
                }
            });

            selectedNode = closestNode;
            draw();
        });

        // Handle mouse move for tooltip
        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            let closestNode = null;
            nodes.forEach((node, i) => {
                const rotated = rotateY(node.x, node.z, rotation);
                const proj = project(rotated.x, node.y, rotated.z + 300);
                const dist = Math.sqrt((mouseX - proj.x) ** 2 + (mouseY - proj.y) ** 2);
                if (dist < 20 * proj.scale) {
                    closestNode = node;
                }
            });

            if (closestNode) {
                tooltip.style.display = 'block';
                tooltip.style.left = `${event.clientX + 10}px`;
                tooltip.style.top = `${event.clientY + 10}px`;
                tooltip.textContent = closestNode.name;
            } else {
                tooltip.style.display = 'none';
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        });

        // Start animation
        animate();
    </script>
</body>
</html>