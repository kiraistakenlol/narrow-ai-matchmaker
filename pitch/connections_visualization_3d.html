<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interconnected Network Visualization (Custom 3D)</title>
    <!-- Load THREE, OrbitControls, and SpriteText -->
    <script src="//unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script src="//unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
    <script src="//unpkg.com/three-spritetext@1.9.6"></script>
    <style>
        body { margin: 0; background-color: #111; color: #fff; overflow: hidden; }
        #controls {
             position: absolute;
             top: 10px;
             left: 10px;
             background-color: rgba(50, 50, 50, 0.85);
             padding: 10px;
             border-radius: 5px;
             font-family: sans-serif;
             z-index: 10;
             color: #eee;
             max-width: 180px; /* Adjust width */
        }
        #controls > div { margin-bottom: 8px; }
        #controls label, #controls span {
            vertical-align: middle;
            display: block; margin-bottom: 2px;
        }
         #controls label { margin-right: 5px; font-size: 0.9em; }
        #controls input[type=range] {
            width: 100%; margin-bottom: 5px;
        }
        #legend { margin-top: 10px; font-size: 0.8em; }
        #legend div { margin-bottom: 2px; }
        #legend span { display: inline-block; width: 10px; height: 10px; margin-right: 5px; border: 1px solid #555; vertical-align: middle; }

        #profileDetails {
            position: absolute;
            width: 250px;
            background-color: rgba(40, 40, 40, 0.95);
            padding: 15px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 10;
            color: #eee;
            display: none;
            border: 1px solid #555;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            pointer-events: auto;
            transform: translate(15px, -50%);
        }
        #profileDetails h3 {
            margin-top: 0; margin-bottom: 10px; color: #ffa500;
             border-bottom: 1px solid #555; padding-bottom: 5px;
        }
         #profileDetails p { margin: 5px 0; font-size: 0.9em; }
        #profileDetails strong { color: #bbb; }
        #profileDetails ul { list-style: none; padding-left: 0; margin-top: 5px; font-size: 0.9em; }
        #profileDetails li { display: inline-block; background-color: #555; color: #eee; padding: 2px 6px; margin: 2px; border-radius: 3px; font-size: 0.85em; }
        #closeDetails { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; color: #aaa; font-size: 1.2em; }
    </style>
</head>
<body>

<div id="container"></div> <!-- Container for renderer -->

<div id="controls">
    <div>
        <label for="speedSlider">Rotation Speed:</label>
        <input type="range" id="speedSlider" name="speedSlider" min="-10" max="10" value="1" step="0.5">
        <span id="speedValue">1</span>
    </div>
    <div id="legend">
        <div><span style="background-color: #ff6347;"></span> Strong</div>
        <div><span style="background-color: #ffd700;"></span> Medium</div>
        <div><span style="background-color: #aec6cf;"></span> Weak</div>
    </div>
</div>

<!-- Added Profile Details Panel -->
<div id="profileDetails">
    <span id="closeDetails" onclick="hideProfileDetails()">&times;</span>
    <h3 id="detailsName"></h3>
    <p><strong>Summary:</strong> <span id="detailsSummary"></span></p>
    <p><strong>Skills:</strong></p>
    <ul id="detailsSkills"></ul>
</div>

<script>
    // --- Basic Three.js Setup ---
    let scene, camera, renderer, controls;
    let container = document.getElementById('container');
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();
    let hoverNode = null;
    const highlightLinks = new Set(); // Keep track of links connected to hoverNode
    let selectedNode = null; // Keep track of clicked node
    const profileDetailsDiv = document.getElementById('profileDetails');

    // --- Simulation Data & Objects ---
    const N_USERS = 10;

    // Enhanced User Data
    const userProfiles = [
        { id: 0, name: 'You', summary: 'Seeking Connections', skills: ['Networking', 'Curiosity'] },
        { id: 1, name: 'Alice', summary: 'Software Engineer', skills: ['JavaScript', 'React', 'Node.js', 'Cloud'] },
        { id: 2, name: 'Bob', summary: 'Product Manager', skills: ['Roadmap', 'Agile', 'UX', 'Market Research'] },
        { id: 3, name: 'Charlie', summary: 'Data Scientist', skills: ['Python', 'ML', 'SQL', 'Statistics'] },
        { id: 4, name: 'Diana', summary: 'UX Designer', skills: ['Figma', 'Prototyping', 'User Research', 'Accessibility'] },
        { id: 5, name: 'Ethan', summary: 'Marketing Specialist', skills: ['SEO', 'Content Strategy', 'Social Media', 'Analytics'] },
        { id: 6, name: 'Fiona', summary: 'Journalist', skills: ['Writing', 'Interviewing', 'Research', 'Storytelling'] },
        { id: 7, name: 'George', summary: 'Hardware Engineer', skills: ['PCB Design', 'Embedded Systems', 'VHDL'] },
        { id: 8, name: 'Hannah', summary: 'Investor', skills: ['VC', 'Startups', 'Finance', 'Due Diligence'] },
        { id: 9, name: 'Ian', summary: 'DevOps Engineer', skills: ['Kubernetes', 'AWS', 'CI/CD', 'Terraform'] }
    ];

    const users = userProfiles.map(profile => ({
        ...profile, // Spread existing profile data
        isYou: profile.id === 0,
        position: new THREE.Vector3(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
        ),
        velocity: new THREE.Vector3(),
        force: new THREE.Vector3(),
        threeObj: null
    }));

    const userMap = new Map(users.map(u => [u.id, u]));
    const connectionLinks = [];
    const lineObjects = new Map(); // Map link key to THREE.Line
    const STRENGTH_LEVELS = ['weak', 'medium', 'strong'];

    for (let i = 0; i < users.length; i++) {
        for (let j = i + 1; j < users.length; j++) {
            const strength = STRENGTH_LEVELS[Math.floor(Math.random() * STRENGTH_LEVELS.length)];
            const link = { source: users[i].id, target: users[j].id, strength: strength };
            connectionLinks.push(link);
            // Use a consistent key for the map
            lineObjects.set(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`, null);
        }
    }

    // --- Physics Parameters ---
    const REPULSION_STRENGTH = 2500;
    const SPRING_CONSTANT = 0.06;
    const RESTING_DISTANCE_BASE = 50;
    const CENTERING_STRENGTH = 0.015;
    const DAMPING = 0.94;
    const TIME_STEP = 0.02;
    let physicsActive = true;

    // --- Styling ---
    const nodeSizeBase = 3.0;
    const nodeSizeHover = 5.0;
    const textHeightBase = 3.5;
    const textHeightHover = 5.5;

    // --- Initialization ---
    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        // Camera
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 120;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Controls
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.0;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xcccccc); // Slightly brighter ambient
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
        directionalLight.position.set(1, 1.5, 1).normalize();
        scene.add(directionalLight);

        // Create 3D Objects
        createGraphObjects();

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('click', onDocumentMouseClick, false); // Add click listener
        controls.addEventListener('start', () => { physicsActive = false; /* Pause physics on drag */ });
        controls.addEventListener('end', () => { physicsActive = true; });

        setupControls();
    }

    function createGraphObjects() {
        // Nodes (Spheres + Labels)
        users.forEach(user => {
            const nodeSize = nodeSizeBase;
            const nodeColor = user.isYou ? '#9c27b0' : '#6baed6'; // Purple for You, blue for others

            const geometry = new THREE.SphereGeometry(nodeSize, 16, 8);
            const material = new THREE.MeshStandardMaterial({
                color: nodeColor,
                metalness: 0.3, roughness: 0.4
            });
            const sphere = new THREE.Mesh(geometry, material);

            const sprite = new SpriteText(user.name);
            sprite.material.depthWrite = false;
            sprite.renderOrder = 1;
            sprite.color = '#eeeeee';
            sprite.textHeight = textHeightBase;

            const yOffset = nodeSize + (sprite.textHeight * 0.8) + 1;
            sprite.position.set(0, yOffset, 0);

            const group = new THREE.Group();
            group.add(sphere);
            group.add(sprite);
            group.position.copy(user.position);
            group.userData = { id: user.id, type: 'node' };

            user.threeObj = group;
            scene.add(group);
        });

        // Links (Lines)
        connectionLinks.forEach(link => {
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);
            if (!sourceUser || !targetUser) return;

            const points = [sourceUser.position, targetUser.position];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const style = getLinkStyle(link.strength);
            const material = new THREE.LineBasicMaterial({
                color: style.color,
                linewidth: 1, // Linewidth > 1 often ignored
                transparent: true,
                opacity: style.opacity
            });

            const line = new THREE.Line(geometry, material);
            line.userData = { link: link };

            scene.add(line);
            lineObjects.set(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`, line);
        });
    }

    function updatePhysics() {
        if (!physicsActive) return;
        users.forEach(user => user.force.set(0, 0, 0));

        // Repulsion
        for (let i = 0; i < users.length; i++) {
            for (let j = i + 1; j < users.length; j++) {
                const userA = users[i];
                const userB = users[j];
                const delta = new THREE.Vector3().subVectors(userA.position, userB.position);
                const distanceSq = delta.lengthSq();
                if (distanceSq > 0.01) { // Avoid self-repulsion / division by zero
                    const distance = Math.sqrt(distanceSq);
                    const forceMagnitude = REPULSION_STRENGTH / distanceSq;
                    const force = delta.normalize().multiplyScalar(forceMagnitude);
                    userA.force.add(force);
                    userB.force.sub(force);
                } else {
                     // Add tiny random push if exactly overlapping
                    userA.force.add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.1));
                }
            }
        }

        // Link Spring Attraction
        connectionLinks.forEach(link => {
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);
            if (!sourceUser || !targetUser) return;

            const delta = new THREE.Vector3().subVectors(sourceUser.position, targetUser.position);
            const distance = delta.length();

            let strengthFactor = 1.0;
            if (link.strength === 'medium') strengthFactor = 1.5;
            if (link.strength === 'strong') strengthFactor = 2.0;
            const restingDistance = RESTING_DISTANCE_BASE / strengthFactor;

            if (distance > 0) {
                const displacement = distance - restingDistance;
                const forceMagnitude = -SPRING_CONSTANT * displacement * strengthFactor; // Stronger links pull harder
                const force = delta.normalize().multiplyScalar(forceMagnitude);
                sourceUser.force.add(force);
                targetUser.force.sub(force);
            }
        });

        // Centering Force
        users.forEach(user => {
            const force = new THREE.Vector3().copy(user.position).multiplyScalar(-CENTERING_STRENGTH);
            user.force.add(force);
        });

        // Update positions
        users.forEach(user => {
            user.velocity.add(user.force.multiplyScalar(TIME_STEP));
            user.velocity.multiplyScalar(DAMPING);
            user.position.add(user.velocity.multiplyScalar(TIME_STEP));
        });
    }

    function updateGraphObjects() {
        const highlightLinkSet = new Set();
        if (hoverNode) {
             highlightLinks.forEach(link => {
                 highlightLinkSet.add(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`);
             });
        }

        // Update Nodes
        users.forEach(user => {
            if (user.threeObj) {
                user.threeObj.position.copy(user.position);
                const isHovered = user === hoverNode;
                const sphereMesh = user.threeObj.children[0];
                const labelSprite = user.threeObj.children[1];
                const nodeSize = isHovered ? nodeSizeHover : nodeSizeBase;

                // Efficiently update only if needed
                const targetScale = isHovered ? nodeSizeHover / nodeSizeBase : 1;
                if (sphereMesh.scale.x !== targetScale) sphereMesh.scale.setScalar(targetScale);
                // Define base color based on isYou, hover color is always orange
                const baseColor = user.isYou ? '#9c27b0' : '#6baed6';
                const targetColor = isHovered ? '#ffa500' : baseColor;
                // Make selected node stand out slightly if not hovered
                const finalColor = (user === selectedNode && !isHovered) ? '#ffeb3b' : targetColor; // Yellow if selected and not hovered
                if (sphereMesh.material.color.getHexString() !== finalColor.substring(1)) sphereMesh.material.color.set(finalColor);

                const targetTextColor = isHovered ? '#ffffff' : '#eeeeee';
                if(labelSprite.color !== targetTextColor) labelSprite.color = targetTextColor;
                const targetTextHeight = isHovered ? textHeightHover : textHeightBase;
                if (labelSprite.textHeight !== targetTextHeight) {
                    labelSprite.textHeight = targetTextHeight;
                    const yOffset = nodeSize + (labelSprite.textHeight * 0.8) + 1;
                    labelSprite.position.set(0, yOffset, 0);
                }
            }
        });

        // Update Links
        connectionLinks.forEach(link => {
            const lineKey = `${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`;
            const line = lineObjects.get(lineKey);
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);

            if (line && sourceUser && targetUser) {
                const positions = line.geometry.attributes.position;
                positions.setXYZ(0, sourceUser.position.x, sourceUser.position.y, sourceUser.position.z);
                positions.setXYZ(1, targetUser.position.x, targetUser.position.y, targetUser.position.z);
                positions.needsUpdate = true;
                line.geometry.computeBoundingSphere();

                const isHighlighted = highlightLinkSet.has(lineKey);
                const style = getLinkStyle(link.strength);
                const targetColor = isHighlighted ? style.highlightColor : style.color;
                if (line.material.color.getHexString() !== targetColor.substring(1)) line.material.color.set(targetColor);
                line.material.opacity = isHighlighted ? 0.9 : style.opacity;
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();
        updateGraphObjects();
        checkHover();
        controls.update();
        renderer.render(scene, camera);
    }

    function checkHover() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        let intersectedNodeId = null;
        for (let i = 0; i < intersects.length; i++) {
            let obj = intersects[i].object;
            while (obj && obj.parent !== scene) {
                if (obj.userData.type === 'node') {
                    intersectedNodeId = obj.userData.id;
                    break;
                }
                obj = obj.parent;
            }
            if (intersectedNodeId !== null) break;
        }
        const newHoverNode = intersectedNodeId !== null ? userMap.get(intersectedNodeId) : null;
        if (newHoverNode !== hoverNode) {
            onNodeHover(newHoverNode);
        }
    }

     function onNodeHover(node) {
        hoverNode = node || null;
        highlightLinks.clear();
        if (hoverNode) {
            connectionLinks.forEach(link => {
                if (link.source === hoverNode.id || link.target === hoverNode.id) {
                    highlightLinks.add(link);
                }
            });
        }
    }

    function getLinkStyle(strength) {
         let color, highlightColor, opacity;
        switch (strength) {
            case 'strong': color = '#ff6347'; highlightColor = '#ff8a65'; opacity = 0.75; break; // Tomato
            case 'medium': color = '#ffd700'; highlightColor = '#ffea00'; opacity = 0.6; break; // Gold
            case 'weak':
            default:       color = '#aec6cf'; highlightColor = '#ddebf0'; opacity = 0.4; break; // LightSteelBlue
        }
        return { color: color, highlightColor: highlightColor, opacity: opacity };
    }

    function setupControls() {
        const speedSlider = document.getElementById('speedSlider');
        const speedValueSpan = document.getElementById('speedValue');
        speedSlider.oninput = function() {
            const speed = parseFloat(this.value);
            speedValueSpan.textContent = speed.toFixed(1);
            if (controls) { controls.autoRotateSpeed = speed; }
        }
        speedSlider.dispatchEvent(new Event('input'));
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

     function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    // --- New Click Handling --- //
    function onDocumentMouseClick(event) {
        console.log("Document clicked"); // Log 1: Check if function is called
        // Use same mouse coordinates as hover
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        console.log("Intersects found:", intersects.length); // Log 2: Check intersections

        let clickedNodeId = null;
        for (let i = 0; i < intersects.length; i++) {
            let intersectedObject = intersects[i].object; // The actual mesh/sprite hit
            let currentObject = intersectedObject;

            // Walk up the hierarchy from the intersected object
            while (currentObject && currentObject !== scene) {
                if (currentObject.userData && currentObject.userData.type === 'node') {
                    clickedNodeId = currentObject.userData.id;
                    // console.log("Found node group:", currentObject); // Optional debug
                    break; // Exit the inner while loop
                }
                currentObject = currentObject.parent;
            }

            if (clickedNodeId !== null) {
                break; // Exit the outer for loop as we found our node
            }
        }
        // console.log(`Final clickedNodeId: ${clickedNodeId}`); // Optional debug
        const clickedNode = clickedNodeId !== null ? userMap.get(clickedNodeId) : null;
        console.log("Clicked Node:", clickedNode); // Log 3: Check if a node was identified

        if (clickedNode) {
            onNodeClick(clickedNode);
        } else {
             // Check if click was outside the details panel
            if (profileDetailsDiv.style.display !== 'none' && !profileDetailsDiv.contains(event.target)) {
                hideProfileDetails();
            }
        }
    }

    function onNodeClick(node) {
        console.log("onNodeClick called for:", node.name); // Log 4: Check if this is called
        selectedNode = node;

        // Stop auto-rotation
        if (controls) controls.autoRotate = false;

        // Calculate screen position
        const screenPosition = getScreenPosition(node.threeObj, camera);

        displayProfileDetails(node, screenPosition.x, screenPosition.y);
    }

    // --- Helper to get screen position --- //
    function getScreenPosition(object3D, camera) {
        const vector = new THREE.Vector3();

        // Get world position
        object3D.updateMatrixWorld();
        vector.setFromMatrixPosition(object3D.matrixWorld);

        // Project to NDC space
        vector.project(camera);

        // Convert to screen coordinates (pixels)
        const screenX = Math.round(((vector.x + 1) / 2) * window.innerWidth);
        const screenY = Math.round(((-vector.y + 1) / 2) * window.innerHeight);

        return { x: screenX, y: screenY };
    }
    // --- End Helper --- //

    function displayProfileDetails(user, x, y) {
        console.log("Displaying details for:", user.name, `at (${x}, ${y})`); // Log 5: Check display function is called
        document.getElementById('detailsName').textContent = user.name;
        document.getElementById('detailsSummary').textContent = user.summary;
        const skillsList = document.getElementById('detailsSkills');
        skillsList.innerHTML = ''; // Clear previous skills
        user.skills.forEach(skill => {
            const li = document.createElement('li');
            li.textContent = skill;
            skillsList.appendChild(li);
        });
        profileDetailsDiv.style.display = 'block';

        // Position the popup
        const popupWidth = profileDetailsDiv.offsetWidth;
        const popupHeight = profileDetailsDiv.offsetHeight;
        const offsetX = 15; // Offset defined in transform: translate(15px,...)
        const verticalOffset = -popupHeight / 2; // Center vertically due to transform: translate(..., -50%)

        let finalX = x + offsetX;
        let finalY = y + verticalOffset;

        // Adjust if going off-screen horizontally
        if (finalX + popupWidth > window.innerWidth) {
            finalX = x - popupWidth - offsetX; // Flip to the left side
             profileDetailsDiv.style.transform = `translate(${-popupWidth - offsetX}px, -50%)`;
        } else {
             profileDetailsDiv.style.transform = `translate(${offsetX}px, -50%)`;
        }

         // Adjust if going off-screen vertically
        if (finalY < 0) {
            finalY = 10; // Push down from top edge
            profileDetailsDiv.style.transform = `translate(${offsetX}px, 0)`; // Adjust transform if needed
        } else if (finalY + popupHeight > window.innerHeight) {
             finalY = window.innerHeight - popupHeight - 10; // Push up from bottom edge
             profileDetailsDiv.style.transform = `translate(${offsetX}px, ${-popupHeight}px)`; // Adjust transform if needed
        }

        profileDetailsDiv.style.left = `${x}px`;
        profileDetailsDiv.style.top = `${y}px`;
        console.log("Final popup position (style.left, style.top):", profileDetailsDiv.style.left, profileDetailsDiv.style.top);

    }

    function hideProfileDetails() {
        selectedNode = null;
        profileDetailsDiv.style.display = 'none';

        // Resume auto-rotation
        if (controls) controls.autoRotate = true;
    }

    // --- End New Click Handling --- //

</script>

</body>
</html> 