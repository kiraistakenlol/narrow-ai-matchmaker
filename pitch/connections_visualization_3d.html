<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interconnected Network Visualization (Custom 3D)</title>
    <!-- Load THREE Core -->
    <script src="//unpkg.com/three@0.140.0/build/three.min.js"></script>
    <!-- JSM Imports for Controls and Lines - Requires type="module" below -->
    <script type="importmap">
        {
            "imports": {
                "three": "//unpkg.com/three@0.140.0/build/three.module.js",
                "three/addons/": "//unpkg.com/three@0.140.0/examples/jsm/"
            }
        }
    </script>
    <!-- SpriteText still loaded normally -->
    <script src="//unpkg.com/three-spritetext@1.9.6"></script>
    <style>
        body { margin: 0; background-color: #1A1A1D; color: #E9ECEF; overflow: hidden; }
        #controls {
             position: absolute;
             top: 10px;
             left: 10px;
             background-color: rgba(40, 40, 45, 0.9);
             padding: 10px;
             border-radius: 5px;
             font-family: sans-serif;
             z-index: 10;
             color: #E9ECEF;
             max-width: 180px;
             border: 1px solid #495057;
        }
        #controls > div { margin-bottom: 8px; }
        #controls label, #controls span {
            vertical-align: middle;
            display: block; margin-bottom: 2px;
        }
         #controls label { margin-right: 5px; font-size: 0.9em; }
        #controls input[type=range] {
            width: 100%; margin-bottom: 5px;
        }
        #legend { margin-top: 10px; font-size: 0.8em; }
        #legend div { margin-bottom: 3px; }
        #legend span { display: inline-block; width: 10px; height: 10px; margin-right: 5px; border: 1px solid #495057; vertical-align: middle; }

        #profileDetails {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background-color: rgba(40, 40, 45, 0.95);
            padding: 15px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 10;
            color: #E9ECEF;
            display: none;
            border: 1px solid #495057;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        #profileDetails h3 {
            margin-top: 0; margin-bottom: 10px; color: #E0A800;
             border-bottom: 1px solid #495057; padding-bottom: 5px;
        }
         #profileDetails p { margin: 5px 0; font-size: 0.9em; }
        #profileDetails strong { color: #adb5bd; }
        #profileDetails ul { list-style: none; padding-left: 0; margin-top: 5px; font-size: 0.9em; }
        #profileDetails li { display: inline-block; background-color: #495057; color: #E9ECEF; padding: 2px 6px; margin: 2px; border-radius: 3px; font-size: 0.85em; }
        #closeDetails { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; color: #adb5bd; font-size: 1.2em; }
    </style>
</head>
<body>

<div id="container"></div> <!-- Container for renderer -->

<div id="controls">
    <div id="legend">
        <div><span style="background-color: #FFA500;"></span> Strong</div>
        <div><span style="background-color: #28A745;"></span> Medium</div>
        <div><span style="background-color: #0D6EFD;"></span> Weak</div>
    </div>
</div>

<!-- Added Profile Details Panel -->
<div id="profileDetails">
    <span id="closeDetails" onclick="hideProfileDetails()">&times;</span>
    <h3 id="detailsName"></h3>
    <p><strong>Summary:</strong> <span id="detailsSummary"></span></p>
    <p><strong>Skills:</strong></p>
    <ul id="detailsSkills"></ul>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { LineMaterial } from 'three/addons/lines/LineMaterial.js';
    import { LineSegmentsGeometry } from 'three/addons/lines/LineSegmentsGeometry.js';
    import { LineSegments2 } from 'three/addons/lines/LineSegments2.js';

    // --- Basic Three.js Setup ---
    let scene, camera, renderer, controls;
    let container = document.getElementById('container');
    let mouse = new THREE.Vector2();
    let raycaster = new THREE.Raycaster();
    let hoverNode = null;
    const highlightLinks = new Set(); // Keep track of links connected to hoverNode
    let selectedNode = null; // Keep track of clicked node
    const profileDetailsDiv = document.getElementById('profileDetails');
    let textureLoader; // Define texture loader globally

    // --- Simulation Data & Objects ---
    const N_USERS = 10;

    // Enhanced User Data
    const userProfiles = [
        { id: 0, name: 'You', summary: 'Seeking Connections', skills: ['Networking', 'Curiosity'], photoUrl: 'https://picsum.photos/seed/0/150' },
        { id: 1, name: 'Alice', summary: 'Software Engineer', skills: ['JavaScript', 'React', 'Node.js', 'Cloud'], photoUrl: 'https://picsum.photos/seed/1/150' },
        { id: 2, name: 'Bob', summary: 'Product Manager', skills: ['Roadmap', 'Agile', 'UX', 'Market Research'], photoUrl: 'https://picsum.photos/seed/2/150' },
        { id: 3, name: 'Charlie', summary: 'Data Scientist', skills: ['Python', 'ML', 'SQL', 'Statistics'], photoUrl: 'https://picsum.photos/seed/3/150' },
        { id: 4, name: 'Diana', summary: 'UX Designer', skills: ['Figma', 'Prototyping', 'User Research', 'Accessibility'], photoUrl: 'https://picsum.photos/seed/4/150' },
        { id: 5, name: 'Ethan', summary: 'Marketing Specialist', skills: ['SEO', 'Content Strategy', 'Social Media', 'Analytics'], photoUrl: 'https://picsum.photos/seed/5/150' },
        { id: 6, name: 'Fiona', summary: 'Journalist', skills: ['Writing', 'Interviewing', 'Research', 'Storytelling'], photoUrl: 'https://picsum.photos/seed/6/150' },
        { id: 7, name: 'George', summary: 'Hardware Engineer', skills: ['PCB Design', 'Embedded Systems', 'VHDL'], photoUrl: 'https://picsum.photos/seed/7/150' },
        { id: 8, name: 'Hannah', summary: 'Investor', skills: ['VC', 'Startups', 'Finance', 'Due Diligence'], photoUrl: 'https://picsum.photos/seed/8/150' },
        { id: 9, name: 'Ian', summary: 'DevOps Engineer', skills: ['Kubernetes', 'AWS', 'CI/CD', 'Terraform'], photoUrl: 'https://picsum.photos/seed/9/150' }
    ];

    const users = userProfiles.map(profile => ({
        ...profile, // Spread existing profile data
        isYou: profile.id === 0,
        position: new THREE.Vector3(
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80,
            (Math.random() - 0.5) * 80
        ),
        velocity: new THREE.Vector3(),
        force: new THREE.Vector3(),
        threeObj: null
    }));

    const userMap = new Map(users.map(u => [u.id, u]));
    const connectionLinks = [];
    const lineObjects = new Map(); // Map link key to THREE.Line
    const STRENGTH_LEVELS = ['weak', 'medium', 'strong'];

    for (let i = 0; i < users.length; i++) {
        for (let j = i + 1; j < users.length; j++) {
            const strength = STRENGTH_LEVELS[Math.floor(Math.random() * STRENGTH_LEVELS.length)];
            const link = { source: users[i].id, target: users[j].id, strength: strength };
            connectionLinks.push(link);
            // Use a consistent key for the map
            lineObjects.set(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`, null);
        }
    }

    // --- Physics Parameters ---
    const REPULSION_STRENGTH = 2500;
    const SPRING_CONSTANT = 0.06;
    const RESTING_DISTANCE_BASE = 45; // *** Slightly reduced base ***
    const CENTERING_STRENGTH = 0.015;
    const DAMPING = 0.94;
    const TIME_STEP = 0.02;
    let physicsActive = true;

    // --- Styling --- (Adjust sizes for Sprites and Text)
    const nodeSizeBase = 8.0; // Base size for sprite scale
    const nodeSizeHover = 11.0; // Hover size for sprite scale (slightly smaller hover)
    const nodeSizeSelected = 13.0; // *** Selected node size ***
    const textHeightBase = 2.5; // Size for SpriteText
    const textHeightHover = 3.0; // Text height for hover/selected
    const borderSize = 0.6;
    const borderColor = '#6C757D';
    const borderYouColor = '#E0A800';
    const defaultTextColor = '#E9ECEF';
    const hoverTextColor = '#FFFFFF';
    const canvasSize = 256; // Resolution for combined texture canvas
    const selectedBorderColor = '#28A745'; // Green for selected node border
    const selectedLinkOpacity = 1.0;
    // const baseLineWidth = 3.0; // Removed uniform width
    // const selectedLineWidth = 5.0; // Removed uniform width

    // *** Strength-based line widths ***
    const strongBaseWidth = 3.5;
    const mediumBaseWidth = 2.5;
    const weakBaseWidth = 1.5;
    const selectedStrongWidth = 5.5;
    const selectedMediumWidth = 4.5;
    const selectedWeakWidth = 3.5;
    const dimmedOpacity = 0.4; // *** Increased dimmed opacity further ***
    const dimmedLineWidth = 1.5; // *** Increased dimmed width further ***
    // const dimmedColor = '#555555'; // *** Removed dimmed color ***

    // --- Initialization ---
    init();
    animate();

    function init() {
        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1A1A1D); // *** Updated background color ***

        // Camera
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 120;

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.autoRotate = true;
        // *** Set Zoom Limits ***
        controls.minDistance = 20; // Min distance camera can approach center
        controls.maxDistance = 300; // Max distance camera can move away

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.8); // Slightly adjusted ambient intensity
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6); // Slightly adjusted directional intensity
        directionalLight.position.set(1, 1.5, 1).normalize();
        scene.add(directionalLight);

        // Create 3D Objects
        createGraphObjects();

        // Event Listeners
        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('click', onDocumentMouseClick, false); // Add click listener
        controls.addEventListener('start', () => { physicsActive = false; });
        controls.addEventListener('end', () => { physicsActive = true; });
    }

    function createGraphObjects() {
        textureLoader = new THREE.TextureLoader(); // Initialize texture loader

        // Nodes (Group: Combined Sprite + Text)
        users.forEach(user => {
            // --- Texture Creation with Canvas --- >
            const canvas = document.createElement('canvas');
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            const ctx = canvas.getContext('2d');

            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            user.texture = texture; // Store texture for updates

            const img = new Image();
            img.crossOrigin = "Anonymous"; 
            user.loadedImg = img; // Store image for redraws

            img.onload = () => {
                // Initial draw using the update function
                updateNodeTexture(user, false); // Draw with default border initially
            };
            img.onerror = (err) => { console.error(`Error loading image ${user.photoUrl}:`, err); };
            img.src = user.photoUrl;
            // <--- End Texture Creation <---

            // Create Combined Photo+Border Sprite Material
            const combinedMaterial = new THREE.SpriteMaterial({
                map: texture, // Use the canvas texture
                sizeAttenuation: true,
                transparent: true,
                alphaTest: 0.1 // Keep this to handle potential aliasing at edges
            });

            // Create Combined Sprite
            const combinedSprite = new THREE.Sprite(combinedMaterial);
            combinedSprite.scale.set(nodeSizeBase, nodeSizeBase, 1);
            combinedSprite.renderOrder = 0; // Can be 0 now

            // Create Name Label (SpriteText)
            const nameSprite = new SpriteText(user.name);
            nameSprite.material.depthWrite = false;
            nameSprite.renderOrder = 1; // Render text on top
            nameSprite.color = defaultTextColor;
            nameSprite.textHeight = textHeightBase;
            // Position name below the combined sprite
            const nameOffsetY = -(nodeSizeBase * 0.5 + textHeightBase * 0.6 + borderSize * 0.5); // Offset based on nodeSize + border
            nameSprite.position.set(0, nameOffsetY, 0);

            // Create Group
            const group = new THREE.Group();
            group.add(combinedSprite); // Add the single combined sprite
            group.add(nameSprite);   // Add name Sprite
            group.position.copy(user.position);
            group.userData = { id: user.id, type: 'node' };

            user.threeObj = group; // Store the group
            scene.add(group);
        });

        // Links (Lines)
        connectionLinks.forEach(link => {
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);
            if (!sourceUser || !targetUser) return;

            // Use LineSegmentsGeometry for thick lines
            const lineGeo = new LineSegmentsGeometry();
            // Positions need to be a flat array: [x1, y1, z1, x2, y2, z2]
            lineGeo.setPositions([ sourceUser.position.x, sourceUser.position.y, sourceUser.position.z, targetUser.position.x, targetUser.position.y, targetUser.position.z ]);

            const style = getLinkStyle(link.strength);
            // *** Determine initial width based on strength ***
            let initialLineWidth;
            switch(link.strength) {
                case 'strong': initialLineWidth = strongBaseWidth; break;
                case 'medium': initialLineWidth = mediumBaseWidth; break;
                case 'weak':
                default: initialLineWidth = weakBaseWidth; break;
            }

            const lineMat = new LineMaterial({
                color: style.color,
                linewidth: initialLineWidth, // *** Use strength-specific initial width ***
                opacity: style.opacity,
                transparent: true,
                // depthTest: false, // Optional: render lines on top
                resolution: new THREE.Vector2(window.innerWidth, window.innerHeight) // Must pass screen dimensions
            });

            const line = new LineSegments2(lineGeo, lineMat);
            line.computeLineDistances(); // Required
            line.scale.set(1, 1, 1); // Required
            line.userData = { link: link }; // Keep link data if needed

            scene.add(line);
            lineObjects.set(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`, line);
        });
    }

    function updatePhysics() {
        if (!physicsActive) return;
        users.forEach(user => user.force.set(0, 0, 0));

        // Repulsion
        for (let i = 0; i < users.length; i++) {
            for (let j = i + 1; j < users.length; j++) {
                const userA = users[i];
                const userB = users[j];
                const delta = new THREE.Vector3().subVectors(userA.position, userB.position);
                const distanceSq = delta.lengthSq();
                if (distanceSq > 0.01) { // Avoid self-repulsion / division by zero
                    const distance = Math.sqrt(distanceSq);
                    const forceMagnitude = REPULSION_STRENGTH / distanceSq;
                    const force = delta.normalize().multiplyScalar(forceMagnitude);
                    userA.force.add(force);
                    userB.force.sub(force);
                } else {
                     // Add tiny random push if exactly overlapping
                    userA.force.add(new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).multiplyScalar(0.1));
                }
            }
        }

        // Link Spring Attraction
        connectionLinks.forEach(link => {
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);
            if (!sourceUser || !targetUser) return;

            const delta = new THREE.Vector3().subVectors(sourceUser.position, targetUser.position);
            const distance = delta.length();

            // *** Increased strengthFactor variation ***
            let strengthFactor = 1.0; // Weak
            if (link.strength === 'medium') strengthFactor = 2.0; // Medium x2
            if (link.strength === 'strong') strengthFactor = 4.0; // Strong x4
            const restingDistance = RESTING_DISTANCE_BASE / strengthFactor;

            if (distance > 0) {
                const displacement = distance - restingDistance;
                const forceMagnitude = -SPRING_CONSTANT * displacement * strengthFactor; // Stronger links pull harder
                const force = delta.normalize().multiplyScalar(forceMagnitude);
                sourceUser.force.add(force);
                targetUser.force.sub(force);
            }
        });

        // Centering Force
        users.forEach(user => {
            const force = new THREE.Vector3().copy(user.position).multiplyScalar(-CENTERING_STRENGTH);
            user.force.add(force);
        });

        // Update positions
        users.forEach(user => {
            user.velocity.add(user.force.multiplyScalar(TIME_STEP));
            user.velocity.multiplyScalar(DAMPING);
            user.position.add(user.velocity.multiplyScalar(TIME_STEP));
        });
    }

    function updateGraphObjects() {
        const highlightLinkSet = new Set();
            if (hoverNode) {
             highlightLinks.forEach(link => {
                 highlightLinkSet.add(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`);
             });
        }

        // *** Create Selected Link Set ***
        const selectedLinkSet = new Set();
        if (selectedNode) {
            connectionLinks.forEach(link => {
                if (link.source === selectedNode.id || link.target === selectedNode.id) {
                    selectedLinkSet.add(`${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`);
                    }
                });
            }

        // Update Nodes
        users.forEach(user => {
            if (user.threeObj) {
                user.threeObj.position.copy(user.position);
                const isHovered = user === hoverNode;
                const isSelected = user === selectedNode;
                const combinedSprite = user.threeObj.children[0]; // Get combined sprite
                const nameSprite = user.threeObj.children[1]; // Get name sprite

                // Efficiently update scale only if needed (Selected > Hover > Default)
                let targetScaleBase;
                if (isSelected) {
                    targetScaleBase = nodeSizeSelected;
                } else if (isHovered) {
                    targetScaleBase = nodeSizeHover;
                } else {
                    targetScaleBase = nodeSizeBase;
                }

                if (combinedSprite.scale.x !== targetScaleBase) {
                    combinedSprite.scale.set(targetScaleBase, targetScaleBase, 1);
                }

                // Update text color and height on hover or select
                const targetTextColor = (isHovered || isSelected) ? hoverTextColor : defaultTextColor;
                const targetTextHeight = (isHovered || isSelected) ? textHeightHover : textHeightBase;

                if(nameSprite.color !== targetTextColor) nameSprite.color = targetTextColor;
                if(nameSprite.textHeight !== targetTextHeight) nameSprite.textHeight = targetTextHeight;

                // Recalculate and update name position based on current combined sprite scale
                // Use the actual targetScaleBase determined above for correct offset
                const currentNameOffsetY = -(targetScaleBase * 0.5 + targetTextHeight * 0.6 + borderSize * 0.5); 
                if (nameSprite.position.y !== currentNameOffsetY) {
                    nameSprite.position.y = currentNameOffsetY;
                }
            }
        });

        // Update Links
        connectionLinks.forEach(link => {
            const lineKey = `${Math.min(link.source, link.target)}-${Math.max(link.source, link.target)}`;
            const line = lineObjects.get(lineKey);
            const sourceUser = userMap.get(link.source);
            const targetUser = userMap.get(link.target);

            if (line && sourceUser && targetUser) {
                // Update positions for LineSegmentsGeometry
                line.geometry.setPositions([ sourceUser.position.x, sourceUser.position.y, sourceUser.position.z, targetUser.position.x, targetUser.position.y, targetUser.position.z ]);
                line.geometry.attributes.position.needsUpdate = true; // May not be strictly needed with setPositions
                // line.computeLineDistances(); // Recalculating might impact performance if many lines update

                // Prioritize Selected > Hovered > Default
                const isSelectedLink = selectedLinkSet.has(lineKey);
                const isHighlightedLink = !isSelectedLink && highlightLinkSet.has(lineKey);
                const style = getLinkStyle(link.strength);

                let targetColor;
                let targetOpacity;
                let targetLineWidth;

                // Check if a node is selected and this link is NOT connected to it
                if (selectedNode && !isSelectedLink) {
                    targetColor = style.color;      // *** Keep original color ***
                    targetOpacity = dimmedOpacity;
                    targetLineWidth = dimmedLineWidth;
                }
                // Otherwise, apply normal logic (Selected > Hover > Default)
                else if (isSelectedLink) {
                    // *** Use BASE color, but full opacity and selected thickness ***
                    targetColor = style.color; 
                    targetOpacity = selectedLinkOpacity;
                    // Select width based on strength for selected links
                    switch(link.strength) {
                        case 'strong': targetLineWidth = selectedStrongWidth; break;
                        case 'medium': targetLineWidth = selectedMediumWidth; break;
                        case 'weak':
                        default: targetLineWidth = selectedWeakWidth; break;
                    }
                } else if (isHighlightedLink) {
                    targetColor = style.highlightColor;
                    targetOpacity = 0.95;
                    // Hover keeps base width for that strength
                    switch(link.strength) {
                        case 'strong': targetLineWidth = strongBaseWidth; break;
                        case 'medium': targetLineWidth = mediumBaseWidth; break;
                        case 'weak':
                        default: targetLineWidth = weakBaseWidth; break;
                    }
                } else {
                    targetColor = style.color;
                    targetOpacity = style.opacity;
                    // Default uses base width for that strength
                    switch(link.strength) {
                        case 'strong': targetLineWidth = strongBaseWidth; break;
                        case 'medium': targetLineWidth = mediumBaseWidth; break;
                        case 'weak':
                        default: targetLineWidth = weakBaseWidth; break;
                    }
                }

                // Update material properties
                if (line.material.color.getHexString() !== targetColor.substring(1)) line.material.color.set(targetColor);
                if (line.material.opacity !== targetOpacity) line.material.opacity = targetOpacity;
                if (line.material.linewidth !== targetLineWidth) line.material.linewidth = targetLineWidth;

                // Update material resolution on resize (handled in onWindowResize)
            }
        });
    }

    function animate() {
        requestAnimationFrame(animate);
        updatePhysics();
        updateGraphObjects();
        checkHover();
        controls.update();
        renderer.render(scene, camera);
    }

    function checkHover() {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        let intersectedNodeId = null;
        for (let i = 0; i < intersects.length; i++) {
            let obj = intersects[i].object;
            while (obj && obj.parent !== scene) {
                if (obj.userData.type === 'node') {
                    intersectedNodeId = obj.userData.id;
                    break;
                }
                obj = obj.parent;
            }
            if (intersectedNodeId !== null) break;
        }
        const newHoverNode = intersectedNodeId !== null ? userMap.get(intersectedNodeId) : null;
        if (newHoverNode !== hoverNode) {
            onNodeHover(newHoverNode);
        }
    }

     function onNodeHover(node) {
        hoverNode = node || null;
        highlightLinks.clear();
        if (hoverNode) {
            connectionLinks.forEach(link => {
                if (link.source === hoverNode.id || link.target === hoverNode.id) {
                    highlightLinks.add(link);
                }
            });
        }
    }

    function getLinkStyle(strength) {
         // Updated Link Styles (Removed selectedHighlightColor)
         let color, highlightColor, opacity; // Removed selectedHighlightColor
        switch (strength) {
            // Strong: Orange -> Lighter Orange 
            case 'strong': 
                color = '#FFA500'; // Orange
                highlightColor = '#FFB733'; // Lighter Orange
                // selectedHighlightColor = '#FFC866'; // Removed
                opacity = 0.85; 
                break; 
            // Medium: Green -> Lighter Green
            case 'medium': 
                color = '#28A745'; // Bootstrap Green
                highlightColor = '#34D399'; // Lighter Green
                // selectedHighlightColor = '#6EE7B7'; // Removed
                opacity = 0.75; 
                break; 
            // Weak: Blue -> Lighter Blue
            case 'weak':
            default:       
                color = '#0D6EFD'; // Bootstrap Blue
                highlightColor = '#3B82F6'; // Lighter Blue
                // selectedHighlightColor = '#60A5FA'; // Removed
                opacity = 0.6; 
                break; 
        }
        // Base opacity slightly increased for better default visibility with thickness
        return { color, highlightColor, opacity }; // Removed selectedHighlightColor
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);

        // *** Update line material resolution ***
        lineObjects.forEach(line => {
            if (line && line.material) {
                line.material.resolution.set(window.innerWidth, window.innerHeight);
            }
        });
    }

     function onDocumentMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
    }

    // --- New Click Handling --- //
    function onDocumentMouseClick(event) {
        console.log("Document clicked"); // Log 1: Check if function is called
        // Use same mouse coordinates as hover
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(scene.children, true);
        console.log("Intersects found:", intersects.length); // Log 2: Check intersections

        let clickedNodeId = null;
        for (let i = 0; i < intersects.length; i++) {
            let intersectedObject = intersects[i].object; // The actual mesh/sprite hit
            let currentObject = intersectedObject;

            // Walk up the hierarchy from the intersected object
            while (currentObject && currentObject !== scene) {
                if (currentObject.userData && currentObject.userData.type === 'node') {
                    clickedNodeId = currentObject.userData.id;
                    // console.log("Found node group:", currentObject); // Optional debug
                    break; // Exit the inner while loop
                }
                currentObject = currentObject.parent;
            }

            if (clickedNodeId !== null) {
                break; // Exit the outer for loop as we found our node
            }
        }
        // console.log(`Final clickedNodeId: ${clickedNodeId}`); // Optional debug
        const clickedNode = clickedNodeId !== null ? userMap.get(clickedNodeId) : null;
        console.log("Clicked Node:", clickedNode); // Log 3: Check if a node was identified

        if (clickedNode) {
            onNodeClick(clickedNode);
        } else {
             // Check if click was outside the details panel
            if (profileDetailsDiv.style.display !== 'none' && !profileDetailsDiv.contains(event.target)) {
                hideProfileDetails();
            }
        }
    }

    function onNodeClick(node) {
        console.log("onNodeClick called for:", node.name);

        // If clicking the same node that's already selected, do nothing extra
        if (selectedNode === node) return;

        // Revert previously selected node's border (if exists)
        if (selectedNode) {
            updateNodeTexture(selectedNode, false);
        }

        // Update newly selected node
        updateNodeTexture(node, true);
        selectedNode = node; // Update selectedNode *after* potential revert

        // Stop auto-rotation
        if (controls) controls.autoRotate = false;

        displayProfileDetails(node);
    }

    function displayProfileDetails(user) {
        console.log("Displaying details for:", user.name); 
        document.getElementById('detailsName').textContent = user.name;
        document.getElementById('detailsSummary').textContent = user.summary;
        const skillsList = document.getElementById('detailsSkills');
        skillsList.innerHTML = ''; // Clear previous skills
        user.skills.forEach(skill => {
            const li = document.createElement('li');
            li.textContent = skill;
            skillsList.appendChild(li);
        });
        profileDetailsDiv.style.display = 'block';
    }

    // Attach to window again to make it accessible from onclick attribute
    window.hideProfileDetails = function() {
        // Revert selected node's border before clearing
        if (selectedNode) {
            updateNodeTexture(selectedNode, false);
        }
        selectedNode = null;
        profileDetailsDiv.style.display = 'none';

        // Resume auto-rotation
        if (controls) controls.autoRotate = true;
    }

    // --- New Function to Redraw Node Texture --- //
    function updateNodeTexture(user, isSelected) {
        if (!user || !user.texture || !user.loadedImg || !user.loadedImg.complete || user.loadedImg.naturalWidth === 0) {
            // console.warn("Cannot update texture, image not ready for:", user?.name);
            return; // Image not loaded or ready yet
        }

        const texture = user.texture;
        const canvas = texture.image; // The canvas is the image source for CanvasTexture
        const ctx = canvas.getContext('2d');
        const img = user.loadedImg;

        ctx.clearRect(0, 0, canvasSize, canvasSize);

        // Determine border color
        let currentBorderColor = borderColor; // Default
        if (user.isYou) {
            currentBorderColor = borderYouColor;
        }
        if (isSelected) {
            currentBorderColor = selectedBorderColor;
        }

        // 1. Draw Border Circle
        const center = canvasSize / 2;
        const outerRadius = canvasSize / 2;
        const innerRadius = outerRadius - (borderSize * (canvasSize / (nodeSizeBase * 2)));
        
        ctx.fillStyle = currentBorderColor;
        ctx.beginPath();
        ctx.arc(center, center, outerRadius, 0, Math.PI * 2);
        ctx.fill();

        // 2. Clip to Inner Circle
        ctx.save();
        ctx.beginPath();
        ctx.arc(center, center, innerRadius, 0, Math.PI * 2);
        ctx.clip();

        // 3. Draw Image
        // Ensure the image is fully loaded before drawing
        try {
             if (img.complete && img.naturalWidth > 0) {
                 ctx.drawImage(img, 0, 0, canvasSize, canvasSize);
             } else {
                 console.warn("Image not ready for drawing on canvas for", user.name);
             }
        } catch (e) {
             console.error("Error drawing image to canvas for", user.name, e);
        }
       
        ctx.restore();

        // 4. Update the texture
        texture.needsUpdate = true;
        // console.log(`Updated texture for ${user.name}, selected: ${isSelected}, border: ${currentBorderColor}`); // Debug log
    }
    // --- End Redraw Function --- //

</script>

</body>
</html> 