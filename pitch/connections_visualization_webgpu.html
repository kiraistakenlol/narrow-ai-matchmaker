<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interconnected Network - Native WebGPU</title>
    <style>
        body { margin: 0; background-color: #1A1A1D; color: #E9ECEF; overflow: hidden; }
        #controls {
             position: absolute;
             top: 10px;
             left: 10px;
             background-color: rgba(40, 40, 45, 0.9);
             padding: 10px;
             border-radius: 5px;
             font-family: sans-serif;
             z-index: 10;
             color: #E9ECEF;
             max-width: 180px;
             border: 1px solid #495057;
        }
        #controls > div { margin-bottom: 8px; }
        #controls label, #controls span {
            vertical-align: middle;
            display: block; margin-bottom: 2px;
        }
         #controls label { margin-right: 5px; font-size: 0.9em; }
        #controls input[type=range] {
            width: 100%; margin-bottom: 5px;
        }
        #legend { margin-top: 10px; font-size: 0.8em; }
        #legend div { margin-bottom: 3px; }
        #legend span { display: inline-block; width: 10px; height: 10px; margin-right: 5px; border: 1px solid #495057; vertical-align: middle; }

        #profileDetails {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 250px;
            background-color: rgba(40, 40, 45, 0.95);
            padding: 15px;
            border-radius: 5px;
            font-family: sans-serif;
            z-index: 10;
            color: #E9ECEF;
            display: none;
            border: 1px solid #495057;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5);
            pointer-events: auto;
        }
        #profileDetails h3 {
            margin-top: 0; margin-bottom: 10px; color: #E0A800;
             border-bottom: 1px solid #495057; padding-bottom: 5px;
        }
         #profileDetails p { margin: 5px 0; font-size: 0.9em; }
        #profileDetails strong { color: #adb5bd; }
        #profileDetails ul { list-style: none; padding-left: 0; margin-top: 5px; font-size: 0.9em; }
        #profileDetails li { display: inline-block; background-color: #495057; color: #E9ECEF; padding: 2px 6px; margin: 2px; border-radius: 3px; font-size: 0.85em; }
        #closeDetails { position: absolute; top: 5px; right: 8px; cursor: pointer; font-weight: bold; color: #adb5bd; font-size: 1.2em; }

        #findMeButton {
            display: block;
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background-color: #0D6EFD;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
            text-align: center;
        }
        #findMeButton:hover {
            background-color: #3B82F6;
        }

        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent labels going outside */
            pointer-events: none; /* Allow interaction with canvas underneath */
            z-index: 5; /* Below controls/details but above canvas */
        }
        .node-label {
            position: absolute;
            color: white;
            font-family: sans-serif;
            font-size: 10px;
            text-shadow: 1px 1px 2px black;
            transform: translate(-50%, -50%); /* Center label on point */
            white-space: nowrap;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>

<canvas id="webgpu-canvas" style="width: 100%; height: 100%; display: block;"></canvas>
<div id="labels-container"></div>

<div id="controls">
    <div id="legend">
        <div><span style="background-color: #FFA500;"></span> Strong</div>
        <div><span style="background-color: #28A745;"></span> Medium</div>
        <div><span style="background-color: #0D6EFD;"></span> Weak</div>
    </div>
    <button id="findMeButton">Find Me</button>
</div>

<div id="profileDetails">
    <span id="closeDetails" onclick="hideProfileDetails()">&times;</span>
    <h3 id="detailsName"></h3>
    <p><strong>Summary:</strong> <span id="detailsSummary"></span></p>
    <p><strong>Skills:</strong></p>
    <ul id="detailsSkills"></ul>
</div>

<script type="module">
    // --- Core WebGPU Setup --- >
    let device = null;
    let context = null;
    let presentationFormat = null;
    let nodeRenderPipeline = null;
    let nodeVertexBuffer = null;
    let sphereVertexBuffer = null;
    let sphereIndexBuffer = null;
    let sphereIndexCount = 0;
    let linkRenderPipeline = null;
    let linkVertexBuffer = null;
    let canvas = null;
    // *** Added for camera/transforms ***
    let projectionMatrix = null;
    let viewMatrix = null;
    let modelViewProjectionMatrix = null;
    let cameraPosition = { x: 0, y: 0, z: 5 }; // Simple initial position
    let cameraTarget = { x: 0, y: 0, z: 0 };
    let cameraUp = { x: 0, y: 1, z: 0 };
    let uniformBuffer = null;
    let uniformBindGroup = null;
    let lightingUniformBuffer = null;

    // *** Camera Control State ***
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;
    let cameraAzimuth = Math.PI; // Initial horizontal angle (looking down -Z)
    let cameraElevation = 0; // Initial vertical angle
    let cameraRadius = 5; // Initial distance from target
    const minRadius = 1;
    const maxRadius = 20;
    const rotateSpeed = 150.0; // Increased rotation speed
    const zoomSpeed = 0.01;

    // --- Basic Matrix/Vector Math (Manual Implementation) --- >
    // NOTE: This is a minimal implementation for demonstration.
    // A dedicated math library (like gl-matrix) is usually recommended.
    const mat4 = {
        create: () => new Float32Array(16),
        identity: (out) => {
            out.fill(0);
            out[0] = out[5] = out[10] = out[15] = 1;
            return out;
        },
        perspective: (out, fovy, aspect, near, far) => {
            const f = 1.0 / Math.tan(fovy / 2);
            out[0] = f / aspect;
            out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0;
            out[10] = (far + near) / (near - far);
            out[11] = -1;
            out[12] = 0; out[13] = 0;
            out[14] = (2 * far * near) / (near - far);
            out[15] = 0;
            return out;
        },
        lookAt: (out, eye, center, up) => {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            let eyex = eye.x, eyey = eye.y, eyez = eye.z;
            let upx = up.x, upy = up.y, upz = up.z;
            let centerx = center.x, centery = center.y, centerz = center.z;
            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;
            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0 = 0; x1 = 0; x2 = 0; }
            else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }
            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0 = 0; y1 = 0; y2 = 0; }
             else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }
            out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
            out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
            out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
            return out;
        },
        multiply: (out, a, b) => {
            let a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            let a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            let a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
            let a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
            let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
            out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
            out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
            out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
            out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        }
    };
    // <--- End Matrix Math <---

    // --- Sphere Geometry Generation --- >
    function createSphereGeometry(radius, latitudeBands, longitudeBands) {
        const vertices = [];
        const normals = [];
        const indices = [];

        for (let latNumber = 0; latNumber <= latitudeBands; latNumber++) {
            const theta = latNumber * Math.PI / latitudeBands;
            const sinTheta = Math.sin(theta);
            const cosTheta = Math.cos(theta);

            for (let longNumber = 0; longNumber <= longitudeBands; longNumber++) {
                const phi = longNumber * 2 * Math.PI / longitudeBands;
                const sinPhi = Math.sin(phi);
                const cosPhi = Math.cos(phi);

                const x = cosPhi * sinTheta;
                const y = cosTheta;
                const z = sinPhi * sinTheta;

                // Normal is just the normalized position vector for a sphere at origin
                const normalLength = Math.sqrt(x*x + y*y + z*z);
                const nx = x / normalLength;
                const ny = y / normalLength;
                const nz = z / normalLength;

                vertices.push(radius * x); // Position x
                vertices.push(radius * y); // Position y
                vertices.push(radius * z); // Position z

                normals.push(nx); // Normal x
                normals.push(ny); // Normal y
                normals.push(nz); // Normal z
            }
        }

        for (let latNumber = 0; latNumber < latitudeBands; latNumber++) {
            for (let longNumber = 0; longNumber < longitudeBands; longNumber++) {
                const first = (latNumber * (longitudeBands + 1)) + longNumber;
                const second = first + longitudeBands + 1;

                indices.push(first);       // Triangle 1
                indices.push(second);
                indices.push(first + 1);

                indices.push(second);      // Triangle 2
                indices.push(second + 1);
                indices.push(first + 1);
            }
        }

        return {
            vertices: new Float32Array(vertices),
            normals: new Float32Array(normals),
            indices: new Uint32Array(indices),
            indexCount: indices.length
        };
    }
    // <--- End Sphere Geometry <---

    async function initWebGPU() {
        canvas = document.getElementById('webgpu-canvas');
        if (!navigator.gpu) {
            throw new Error("WebGPU not supported on this browser.");
        }

        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
            throw new Error("No appropriate GPUAdapter found.");
        }

        device = await adapter.requestDevice();
        if (!device) {
            throw new Error("Need a browser that supports WebGPU");
        }

        context = canvas.getContext("webgpu");
        presentationFormat = navigator.gpu.getPreferredCanvasFormat();
        context.configure({
            device: device,
            format: presentationFormat,
            alphaMode: "opaque"
        });

        // --- Create Resources (Nodes) --- >

        // Generate Node Data (Positions)
        const nodePositions = new Float32Array(N_USERS * 3);
        for (let i = 0; i < N_USERS; i++) {
            const user = users[i];
            nodePositions[i * 3 + 0] = user.x;
            nodePositions[i * 3 + 1] = user.y;
            nodePositions[i * 3 + 2] = user.z;
        }

        // Node Vertex Buffer
        nodeVertexBuffer = device.createBuffer({
            label: "Node Vertex Buffer",
            size: nodePositions.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Float32Array(nodeVertexBuffer.getMappedRange()).set(nodePositions);
        nodeVertexBuffer.unmap();

        // --- Create Sphere Geometry for Nodes --- >
        const SPHERE_RADIUS = 0.08; // Small radius for nodes
        const sphereData = createSphereGeometry(SPHERE_RADIUS, 48, 96); // Doubled bands again for max smoothness
        sphereIndexCount = sphereData.indexCount;

        sphereVertexBuffer = device.createBuffer({
            label: "Sphere Vertex Buffer",
            size: sphereData.vertices.byteLength + sphereData.normals.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        // Interleave position and normal data: [pos, norm, pos, norm, ...]
        const sphereInterleavedData = new Float32Array(sphereData.vertices.length + sphereData.normals.length);
        let v_offset = 0;
        let n_offset = 0;
        for (let i = 0; i < sphereInterleavedData.length; i += 6) {
            // Position
            sphereInterleavedData[i + 0] = sphereData.vertices[v_offset++];
            sphereInterleavedData[i + 1] = sphereData.vertices[v_offset++];
            sphereInterleavedData[i + 2] = sphereData.vertices[v_offset++];
            // Normal
            sphereInterleavedData[i + 3] = sphereData.normals[n_offset++];
            sphereInterleavedData[i + 4] = sphereData.normals[n_offset++];
            sphereInterleavedData[i + 5] = sphereData.normals[n_offset++];
        }
        new Float32Array(sphereVertexBuffer.getMappedRange()).set(sphereInterleavedData);
        sphereVertexBuffer.unmap();

        sphereIndexBuffer = device.createBuffer({
            label: "Sphere Index Buffer",
            size: sphereData.indices.byteLength,
            usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Uint32Array(sphereIndexBuffer.getMappedRange()).set(sphereData.indices);
        sphereIndexBuffer.unmap();

        // --- Define Shaders --- >
        // Node Vertex Shader (Instancing)
        const nodeVertexShaderModule = device.createShaderModule({
            label: "Node Vertex Shader Module",
            code: `
                struct CameraUniforms {
                    mvpMatrix : mat4x4<f32>,
                }
                @binding(0) @group(0) var<uniform> camera : CameraUniforms;

                struct VertexOutput {
                    @builtin(position) position : vec4<f32>,
                    @location(0) worldPos: vec3<f32>,
                    @location(1) worldNormal: vec3<f32>,
                }

                @vertex
                fn vs_main(@location(0) sphere_vertex_pos: vec3<f32>,
                           @location(1) instance_pos : vec3<f32>,
                           @location(2) sphere_normal : vec3<f32>) -> VertexOutput {
                    var output : VertexOutput;
                    // Combine instance position with sphere vertex position
                    let world_pos = instance_pos + sphere_vertex_pos;

                    // Position needs MVP transform
                    output.position = camera.mvpMatrix * vec4<f32>(world_pos, 1.0);

                    // Pass world position and normal (assuming no model rotation for simplicity)
                    // For proper lighting with model rotations, transform normal by normal matrix
                    output.worldPos = world_pos;
                    output.worldNormal = normalize(sphere_normal); // Ensure normal is normalized
                    return output;
                }
            `
        });

        // Link Vertex Shader (Simple)
        const linkVertexShaderModule = device.createShaderModule({
            label: "Link Vertex Shader Module",
            code: `
                struct Uniforms {
                    mvpMatrix : mat4x4<f32>,
                }
                @binding(0) @group(0) var<uniform> uniforms : Uniforms;

                struct VertexOutput {
                    @builtin(position) position : vec4<f32>,
                }

                @vertex
                fn vs_main(@location(0) pos: vec3<f32>) -> VertexOutput {
                    var output : VertexOutput;
                    output.position = uniforms.mvpMatrix * vec4<f32>(pos, 1.0);
                    return output;
                }
            `
        });

        const nodeFragmentShaderModule = device.createShaderModule({
            label: "Node Fragment Shader Module",
            code: `
                struct CameraUniforms {
                    mvpMatrix : mat4x4<f32>,
                }
                @binding(0) @group(0) var<uniform> camera : CameraUniforms;

                struct LightingUniforms {
                    lightDirection : vec3<f32>,
                    lightColor : vec3<f32>,
                    ambientColor : vec3<f32>,
                    cameraWorldPos : vec3<f32>,
                }
                @binding(1) @group(0) var<uniform> lighting : LightingUniforms;

                struct FragmentInput {
                    @location(0) worldPos: vec3<f32>,
                    @location(1) worldNormal: vec3<f32>,
                }

                @fragment
                fn fs_main(in: FragmentInput) -> @location(0) vec4<f32> {
                    let N = normalize(in.worldNormal);
                    let L = normalize(lighting.lightDirection);
                    let V = normalize(lighting.cameraWorldPos - in.worldPos);
                    let H = normalize(L + V); // Blinn-Phong halfway vector

                    // Diffuse
                    let NdotL = max(dot(N, L), 0.0);
                    let diffuse = lighting.lightColor * NdotL;

                    // Specular (Blinn-Phong)
                    let NdotH = max(dot(N, H), 0.0);
                    let specularPower = 32.0;
                    let specular = lighting.lightColor * pow(NdotH, specularPower);

                    // Final color
                    let finalColor = lighting.ambientColor + diffuse + specular;

                    // Return color (e.g., yellowish base) modulated by light
                    let baseColor = vec3<f32>(0.9, 0.9, 0.3); // Yellowish base
                    return vec4<f32>(baseColor * finalColor, 1.0);
                }
            `
        });

        const linkFragmentShaderModule = device.createShaderModule({
            label: "Link Fragment Shader Module",
            code: `
                @fragment
                fn fs_main() -> @location(0) vec4<f32> {
                    return vec4<f32>(0.5, 0.5, 0.5, 0.6); // Grey for links
                }
            `
        });

        // Define Layouts NEXT
        const bindGroupLayout = device.createBindGroupLayout({
            label: "Uniform Bind Group Layout",
            entries: [{
                binding: 0,
                visibility: GPUShaderStage.VERTEX,
                buffer: {} // Camera uniforms
            },
            {
                binding: 1,
                visibility: GPUShaderStage.FRAGMENT, // Lighting used in fragment shader
                buffer: {} // Lighting uniforms
            }]
        });

        const pipelineLayout = device.createPipelineLayout({
            label: "Shared Pipeline Layout",
            bindGroupLayouts: [bindGroupLayout]
        });

        // Create Pipelines THIRD (using shaders and layout)
        nodeRenderPipeline = device.createRenderPipeline({
            label: "Node Render Pipeline",
            layout: pipelineLayout,
            vertex: {
                module: nodeVertexShaderModule,
                entryPoint: "vs_main",
                buffers: [
                    // Sphere geometry (per vertex)
                    {
                        arrayStride: 6 * 4, // 6 floats per vertex (3 pos + 3 normal)
                        stepMode: 'vertex',
                        attributes: [
                            // Position
                            {
                                shaderLocation: 0, // Corresponds to @location(0) sphere_vertex_pos
                                offset: 0,
                                format: "float32x3"
                            },
                            // Normal
                            {
                                shaderLocation: 2, // Use location 2 for normals
                                offset: 3 * 4, // Normal data starts after 3 floats (12 bytes)
                                format: "float32x3"
                            }
                        ]
                    },
                    // Node positions (per instance)
                    {
                        arrayStride: 3 * 4, // 3 floats per instance (x, y, z)
                        stepMode: 'instance',
                        attributes: [{
                            shaderLocation: 1, // Corresponds to @location(1) instance_pos
                            offset: 0,
                            format: "float32x3"
                        }]
                    }
                ]
            },
            fragment: {
                module: nodeFragmentShaderModule,
                entryPoint: "fs_main",
                targets: [{
                    format: presentationFormat
                }]
            },
            primitive: {
                topology: "triangle-list",
                cullMode: 'none'
            }
        });

        // Link Render Pipeline
        linkRenderPipeline = device.createRenderPipeline({
            label: "Link Render Pipeline",
            layout: pipelineLayout,
            vertex: {
                module: linkVertexShaderModule,
                entryPoint: "vs_main",
                buffers: [{
                    arrayStride: 3 * 4, // 3 floats (x,y,z) per vertex
                    attributes: [{
                        shaderLocation: 0,
                        offset: 0,
                        format: "float32x3"
                    }]
                }]
            },
            fragment: {
                module: linkFragmentShaderModule,
                entryPoint: "fs_main",
                targets: [{
                    format: presentationFormat
                }]
            },
            primitive: {
                topology: "line-list"
            }
        });

        // Create Uniform Buffer FOURTH
        const matrixSize = 4 * 16; // 4x4 matrix, 4 bytes per float
        uniformBuffer = device.createBuffer({
            size: matrixSize,
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Create Lighting Uniform Buffer
        const lightDirection = new Float32Array([-0.5, -1.0, -0.5]); // Example directional light
        const lightColor = new Float32Array([1.0, 1.0, 1.0]);
        const ambientColor = new Float32Array([0.2, 0.2, 0.2]);
        const cameraWorldPos = new Float32Array([cameraPosition.x, cameraPosition.y, cameraPosition.z]);

        const lightingBufferSize = 64; // Minimum required size based on alignment/binding rules
        lightingUniformBuffer = device.createBuffer({
            label: "Lighting Uniform Buffer",
            size: lightingBufferSize, // Use the required minimum size
            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        // Write initial data respecting 16-byte alignment for vec3s
        device.queue.writeBuffer(lightingUniformBuffer, 0, lightDirection);        // Offset 0
        device.queue.writeBuffer(lightingUniformBuffer, 16, lightColor);       // Offset 16
        device.queue.writeBuffer(lightingUniformBuffer, 32, ambientColor);     // Offset 32
        device.queue.writeBuffer(lightingUniformBuffer, 48, cameraWorldPos);    // Offset 48

        // Create Bind Group FIFTH (using layout and buffer)
        uniformBindGroup = device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
                binding: 0,
                resource: { buffer: uniformBuffer }
            },
            {
                binding: 1,
                resource: { buffer: lightingUniformBuffer }
            }]
        });

        // <--- End Resource Creation <---

        console.log("Native WebGPU Initialized Successfully");
        return true;
    }
    // <--- End WebGPU Setup <---

    // --- Simulation / Application Data --- >
    const N_USERS = 15;
    const users = [];
    const connectionLinks = [];
    let selectedNode = null; // Placeholder for interaction later
    let hoverNode = null; // Placeholder for interaction later
    const profileDetailsDiv = document.getElementById('profileDetails');
    const labelsContainer = document.getElementById('labels-container');
    const labelElements = []; // To store label DOM elements

    // --- Simulation / Application Data Generation Function --- >
    function generateGraphData() {
        users.length = 0; // Clear previous data
        connectionLinks.length = 0;

        const USER_NAMES = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O"];
        const skillsPool = ["JavaScript", "Python", "WebGPU", "Three.js", "React", "Node.js", "AI/ML", "Data Viz", "SQL", "Cloud", "DevOps", "UX Design"];
        const NODE_SPREAD = 4; // How spread out the nodes are initially
        for (let i = 0; i < N_USERS; i++) {
            const name = `Person ${USER_NAMES[i % USER_NAMES.length]}`;
            const numSkills = Math.floor(Math.random() * 4) + 2; // 2-5 skills
            const skills = [];
            while (skills.length < numSkills) {
                const skill = skillsPool[Math.floor(Math.random() * skillsPool.length)];
                if (!skills.includes(skill)) {
                    skills.push(skill);
                }
            }

            users.push({
                id: i,
                name: name,
                summary: `Summary for ${name}.`, // Placeholder summary
                skills: skills,
                // Initial random position (will be updated by physics later)
                x: (Math.random() - 0.5) * NODE_SPREAD,
                y: (Math.random() - 0.5) * NODE_SPREAD,
                z: (Math.random() - 0.5) * NODE_SPREAD,
                // Physics properties (placeholders for now)
                vx: 0, vy: 0, vz: 0
            });
        }

        // Generate Connections (Store them, but don't draw yet)
        for (let i = 0; i < N_USERS; i++) {
            for (let j = i + 1; j < N_USERS; j++) {
                if (Math.random() > 0.5) { // Connect roughly half the pairs
                    connectionLinks.push({
                        source: i,
                        target: j,
                        level: Math.floor(Math.random() * 3) + 1 // 1, 2, or 3
                    });
                }
            }
        }
    }

    // <--- End Simulation Data <---

    // --- Render Loop --- >
    function render() {
        if (!device || !context || !nodeRenderPipeline || !linkRenderPipeline || !canvas) return;

        // *** Update Camera Position from Controls ***
        const camX = cameraTarget.x + cameraRadius * Math.sin(cameraAzimuth) * Math.cos(cameraElevation);
        const camY = cameraTarget.y + cameraRadius * Math.sin(cameraElevation);
        const camZ = cameraTarget.z + cameraRadius * Math.cos(cameraAzimuth) * Math.cos(cameraElevation);
        cameraPosition = { x: camX, y: camY, z: camZ };

        // *** Calculate Matrices ***
        const aspect = canvas.width / canvas.height;
        projectionMatrix = mat4.perspective(mat4.create(), (2 * Math.PI) / 5, aspect, 0.1, 100.0);
        viewMatrix = mat4.lookAt(mat4.create(), cameraPosition, cameraTarget, cameraUp);
        modelViewProjectionMatrix = mat4.multiply(mat4.create(), projectionMatrix, viewMatrix);
        // Note: We need a model matrix too for individual objects, but skipping for now

        // *** Update Uniform Buffer ***
        device.queue.writeBuffer(
            uniformBuffer,
            0, // Offset
            modelViewProjectionMatrix.buffer, // Data source (ArrayBuffer)
            modelViewProjectionMatrix.byteOffset, // Data source offset
            modelViewProjectionMatrix.byteLength // Data source size
        );

        // *** Update Lighting Uniforms (Camera Position) ***
        // Camera position changes, so update the lighting buffer each frame
        const camPosData = new Float32Array([cameraPosition.x, cameraPosition.y, cameraPosition.z]);
        device.queue.writeBuffer(
            lightingUniformBuffer,
            48, // Byte offset for cameraWorldPos (aligned to 16 bytes)
            camPosData.buffer,
            camPosData.byteOffset,
            camPosData.byteLength
        );

        const commandEncoder = device.createCommandEncoder();
        const textureView = context.getCurrentTexture().createView();

        const renderPassDescriptor = {
            colorAttachments: [{
                view: textureView,
                clearValue: { r: 0.1, g: 0.1, b: 0.11, a: 1.0 }, 
                loadOp: 'clear',
                storeOp: 'store'
            }]
        };

        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
        passEncoder.setBindGroup(0, uniformBindGroup); // *** Set Bind Group ONCE for the pass ***

        // Draw Links FIRST
        if (linkVertexBuffer) {
            passEncoder.setPipeline(linkRenderPipeline);
            passEncoder.setVertexBuffer(0, linkVertexBuffer);
            passEncoder.draw(connectionLinks.length * 2, 1, 0, 0);
        }

        // Draw Nodes SECOND (on top) using instancing
        passEncoder.setPipeline(nodeRenderPipeline);
        passEncoder.setVertexBuffer(0, sphereVertexBuffer);   // Slot 0: Sphere vertex positions
        passEncoder.setVertexBuffer(1, nodeVertexBuffer);   // Slot 1: Instance positions
        passEncoder.setIndexBuffer(sphereIndexBuffer, 'uint32'); // Set index buffer
        passEncoder.drawIndexed(sphereIndexCount, N_USERS, 0, 0, 0); // Draw indexed + instanced

        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);

        // --- Update HTML Labels --- >
        updateLabels();
    }

    function animate() {
        render();
        requestAnimationFrame(animate);
    }
    // <--- End Render Loop <---

    // --- HTML Label Creation Function --- >
    function createHtmlLabels() {
        if (!labelsContainer) return;
        labelsContainer.innerHTML = ''; // Clear any previous labels
        labelElements.length = 0;
        for (const user of users) {
            const label = document.createElement('span');
            label.className = 'node-label';
            label.textContent = user.name;
            labelsContainer.appendChild(label);
            labelElements.push(label);
        }
    }

    // --- Label Logic --- >
    function projectToScreen(worldPos) {
        if (!modelViewProjectionMatrix || !canvas) return null;

        // Manual matrix * vector multiplication (worldPos * MVP)
        const x = worldPos.x, y = worldPos.y, z = worldPos.z;
        const m = modelViewProjectionMatrix;
        let clipX = x * m[0] + y * m[4] + z * m[8] + m[12];
        let clipY = x * m[1] + y * m[5] + z * m[9] + m[13];
        //let clipZ = x * m[2] + y * m[6] + z * m[10] + m[14]; // Z for depth test (optional)
        let clipW = x * m[3] + y * m[7] + z * m[11] + m[15];

        // Check if point is behind the camera (or exactly at the eye)
        if (clipW <= 0) {
            return null;
        }

        // Perspective divide (NDC)
        const ndcX = clipX / clipW;
        const ndcY = clipY / clipW;
        //const ndcZ = clipZ / clipW;

        // Check if point is outside NDC bounds (-1 to 1)
        if (ndcX < -1 || ndcX > 1 || ndcY < -1 || ndcY > 1) {
            return null;
        }

        // Convert NDC to screen coordinates (pixels)
        const screenX = (ndcX + 1) / 2 * canvas.width;
        const screenY = (1 - ndcY) / 2 * canvas.height; // Y is inverted in NDC

        return { x: screenX, y: screenY };
    }

    function updateLabels() {
        if (!labelsContainer) return;
        for (let i = 0; i < N_USERS; i++) {
            const user = users[i];
            const label = labelElements[i];
            if (!user || !label) continue;

            const screenPos = projectToScreen(user);

            if (screenPos) {
                label.style.left = `${screenPos.x}px`;
                label.style.top = `${screenPos.y}px`;
                label.style.display = 'block';
            } else {
                label.style.display = 'none';
            }
        }
    }
    // <--- End Label Logic <---

    // --- Event Handlers & Other Logic (Stubs) --- >
    function onWindowResize() {
        if (!canvas) return;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        // TODO: Update projection matrix aspect ratio needs recalculation in render()
        console.log("Window resize (Native WebGPU) - Handled aspect in render()");
    }

    window.hideProfileDetails = function() { // Still needed globally for onclick
        profileDetailsDiv.style.display = 'none';
    }

    // *** Mouse Controls Implementation ***
    function onMouseDown(event) {
        isDragging = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function onMouseUp(event) {
        isDragging = false;
    }

    function onMouseMove(event) {
        if (!isDragging) return;
        const dx = event.clientX - lastMouseX;
        const dy = event.clientY - lastMouseY;

        cameraAzimuth += dx * rotateSpeed * (Math.PI / 180) / canvas.width; // Scale by canvas width
        cameraElevation -= dy * rotateSpeed * (Math.PI / 180) / canvas.height; // Scale by canvas height

        // Clamp elevation to prevent flipping
        cameraElevation = Math.max(-Math.PI / 2 + 0.01, Math.min(Math.PI / 2 - 0.01, cameraElevation));

        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function onWheel(event) {
        event.preventDefault(); // Prevent page scrolling
        cameraRadius += event.deltaY * zoomSpeed;
        cameraRadius = Math.max(minRadius, Math.min(maxRadius, cameraRadius));
    }

    // Placeholder findMe needed for button listener
    function findMe() { console.log("Find Me (Native WebGPU) - TODO"); }

    // --- Main Initialization --- >
    async function main() {
        try {
            // 1. Generate the graph data first
            generateGraphData();

            // 2. Initialize WebGPU (needs N_USERS)
            await initWebGPU();

            // 3. Create GPU buffers (needs users data and device)
            createLinkVertexBuffer();

            // 4. Create HTML labels (needs users data)
            createHtmlLabels();

            // Setup basic listeners
            window.addEventListener('resize', onWindowResize, false);
            canvas.addEventListener('mousedown', onMouseDown, false);
            canvas.addEventListener('mouseup', onMouseUp, false);
            canvas.addEventListener('mousemove', onMouseMove, false);
            canvas.addEventListener('wheel', onWheel, false);

            // Trigger initial resize
            onWindowResize(); 

            // Placeholder for Find Me button listener
            document.getElementById('findMeButton')?.addEventListener('click', (event) => {
                 event?.stopPropagation(); // Need null check if called before init?
                 findMe();
             });

            // Start the animation loop
            animate(); 

        } catch (error) {
            console.error("Initialization failed:", error);
            const errorDiv = document.createElement('div');
            errorDiv.style.cssText = 'color: red; position: absolute; top: 10px; left: 10px; background: black; padding: 5px;';
            errorDiv.textContent = `Failed to initialize WebGPU: ${error.message}`;
            document.body.appendChild(errorDiv);
        }
    }

    // Prepare Link Vertex Data (needs users array populated first)
    function createLinkVertexBuffer() {
        if (!device) return;
        const linkVertexData = new Float32Array(connectionLinks.length * 2 * 3); // 2 verts per link, 3 floats per vert
        let offset = 0;
        for (const link of connectionLinks) {
            const source = users[link.source];
            const target = users[link.target];
            // Source vertex
            linkVertexData[offset++] = source.x;
            linkVertexData[offset++] = source.y;
            linkVertexData[offset++] = source.z;
            // Target vertex
            linkVertexData[offset++] = target.x;
            linkVertexData[offset++] = target.y;
            linkVertexData[offset++] = target.z;
        }

        linkVertexBuffer = device.createBuffer({
            label: "Link Vertex Buffer",
            size: linkVertexData.byteLength,
            usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
            mappedAtCreation: true
        });
        new Float32Array(linkVertexBuffer.getMappedRange()).set(linkVertexData);
        linkVertexBuffer.unmap();
    }

    main();
    // <--- End Main Initialization <---

</script>

</body>
</html> 