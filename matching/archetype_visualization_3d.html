<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Archetype Compatibility Visualization</title>
    <!-- Load THREE first, then SpriteText v1.9.6 (from unpkg), then 3d-force-graph -->
    <script src="//unpkg.com/three@0.140.0/build/three.min.js"></script>
    <script src="//unpkg.com/three-spritetext@1.9.6"></script>
    <script src="//unpkg.com/3d-force-graph@1.71.5/dist/3d-force-graph.min.js"></script>
    <style>
        body { margin: 0; background-color: #111; color: #fff; }
        #controls {
             position: absolute;
             top: 10px;
             left: 10px;
             background-color: rgba(50, 50, 50, 0.85);
             padding: 10px;
             border-radius: 5px;
             font-family: sans-serif;
             z-index: 10;
             color: #eee;
        }
        #controls label, #controls span {
            vertical-align: middle;
        }
         #controls label {
            margin-right: 5px;
        }
        #controls input[type=range] {
            width: 100px; /* Adjusted slider width */
            margin-right: 5px;
            vertical-align: middle;
        }
        #legend {
            margin-top: 10px;
            font-size: 0.8em;
        }
        #legend span {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-right: 5px;
            border: 1px solid #555;
            vertical-align: middle;
        }

    </style>
</head>
<body>

<div id="3d-graph"></div>

<div id="controls">
    <div>
        <label for="scoreSlider">Min Score:</label>
        <input type="range" id="scoreSlider" name="scoreSlider" min="0" max="5" value="0" step="1">
        <span id="scoreValue">0</span>
    </div>
    <div style="margin-top: 5px;">
        <label for="speedSlider">Rot Speed:</label>
        <input type="range" id="speedSlider" name="speedSlider" min="-10" max="10" value="1" step="0.5">
        <span id="speedValue">1</span>
    </div>
    <div id="legend">
        <div><span style="background-color: #ff4500;"></span> 5 (Hot)</div>
        <div><span style="background-color: #ffac33;"></span> 4</div>
        <div><span style="background-color: #ffff66;"></span> 3 (Warm)</div>
        <div><span style="background-color: #77b5fe;"></span> 2</div>
        <div><span style="background-color: #aec6cf;"></span> 1 (Cool)</div>
        <div><span style="background-color: #666666;"></span> 0</div>
    </div>
</div>

<script>
    // Archetype Data
    const archetypes = [
        { id: 1, name: 'Skill Provider' },
        { id: 2, name: 'Opportunity Provider' },
        { id: 3, name: 'Local Connector' },
        { id: 4, name: 'Niche Hobbyist' },
        { id: 5, name: 'Event Attendee' },
        { id: 6, name: 'Mentor' },
        { id: 7, name: 'Problem Holder' },
        { id: 8, name: 'Solution Provider' },
        { id: 9, name: 'Investor' },
        { id: 10, name: 'Event Team Seeker' }
    ];

    // Compatibility Scores
    const originalCompatibilityScores = [
        // Skill Provider (1)
        { source: 1, target: 2, score: 5 }, { source: 1, target: 10, score: 4 }, { source: 1, target: 5, score: 3 },
        { source: 1, target: 6, score: 3 }, { source: 1, target: 8, score: 3 }, { source: 1, target: 7, score: 2 },
        { source: 1, target: 3, score: 1 }, { source: 1, target: 9, score: 1 }, { source: 1, target: 4, score: 0 },
        // Opportunity Provider (2)
        { source: 2, target: 1, score: 5 }, { source: 2, target: 8, score: 4 }, { source: 2, target: 9, score: 4 },
        { source: 2, target: 10, score: 4 }, { source: 2, target: 5, score: 3 }, { source: 2, target: 6, score: 2 },
        { source: 2, target: 3, score: 1 }, { source: 2, target: 7, score: 1 }, { source: 2, target: 4, score: 0 },
        // Local Connector (3)
        { source: 3, target: 3, score: 5 }, { source: 3, target: 4, score: 3 }, { source: 3, target: 5, score: 2 },
        { source: 3, target: 6, score: 2 }, { source: 3, target: 1, score: 1 }, { source: 3, target: 2, score: 1 },
        { source: 3, target: 7, score: 1 }, { source: 3, target: 8, score: 1 }, { source: 3, target: 10, score: 1 },
        { source: 3, target: 9, score: 0 },
        // Niche Hobbyist (4)
        { source: 4, target: 4, score: 5 }, { source: 4, target: 3, score: 3 }, { source: 4, target: 5, score: 1 },
        { source: 4, target: 1, score: 0 }, { source: 4, target: 2, score: 0 }, { source: 4, target: 6, score: 0 },
        { source: 4, target: 7, score: 0 }, { source: 4, target: 8, score: 0 }, { source: 4, target: 9, score: 0 },
        { source: 4, target: 10, score: 0 },
        // Event Attendee (5)
        { source: 5, target: 10, score: 5 }, { source: 5, target: 5, score: 4 }, { source: 5, target: 6, score: 4 },
        { source: 5, target: 1, score: 3 }, { source: 5, target: 2, score: 3 }, { source: 5, target: 7, score: 3 },
        { source: 5, target: 8, score: 3 }, { source: 5, target: 3, score: 2 }, { source: 5, target: 9, score: 2 },
        { source: 5, target: 4, score: 1 },
        // Mentor (6)
        { source: 6, target: 5, score: 4 }, { source: 6, target: 1, score: 3 }, { source: 6, target: 7, score: 3 },
        { source: 6, target: 10, score: 3 }, { source: 6, target: 2, score: 2 }, { source: 6, target: 3, score: 2 },
        { source: 6, target: 6, score: 2 }, { source: 6, target: 8, score: 2 }, { source: 6, target: 9, score: 1 },
        { source: 6, target: 4, score: 0 },
        // Problem Holder (7)
        { source: 7, target: 8, score: 5 }, { source: 7, target: 5, score: 3 }, { source: 7, target: 6, score: 3 },
        { source: 7, target: 1, score: 2 }, { source: 7, target: 7, score: 2 }, { source: 7, target: 10, score: 2 },
        { source: 7, target: 2, score: 1 }, { source: 7, target: 3, score: 1 }, { source: 7, target: 9, score: 1 },
        { source: 7, target: 4, score: 0 },
        // Solution Provider (8)
        { source: 8, target: 7, score: 5 }, { source: 8, target: 2, score: 4 }, { source: 8, target: 1, score: 3 },
        { source: 8, target: 5, score: 3 }, { source: 8, target: 9, score: 3 }, { source: 8, target: 6, score: 2 },
        { source: 8, target: 8, score: 2 }, { source: 8, target: 10, score: 2 }, { source: 8, target: 3, score: 1 },
        { source: 8, target: 4, score: 0 },
        // Investor (9)
        { source: 9, target: 2, score: 4 }, { source: 9, target: 8, score: 3 }, { source: 9, target: 5, score: 2 },
        { source: 9, target: 9, score: 2 }, { source: 9, target: 1, score: 1 }, { source: 9, target: 6, score: 1 },
        { source: 9, target: 7, score: 1 }, { source: 9, target: 10, score: 1 }, { source: 9, target: 3, score: 0 },
        { source: 9, target: 4, score: 0 },
         // Event Team Seeker (10)
        { source: 10, target: 5, score: 5 }, { source: 10, target: 10, score: 5 }, { source: 10, target: 1, score: 4 },
        { source: 10, target: 2, score: 4 }, { source: 10, target: 6, score: 3 }, { source: 10, target: 7, score: 2 },
        { source: 10, target: 8, score: 2 }, { source: 10, target: 9, score: 1 }, { source: 10, target: 3, score: 1 },
        { source: 10, target: 4, score: 0 }
    ];

    // Make links unique
    const uniqueLinks = [];
    const linkSet = new Set();
    originalCompatibilityScores.forEach(link => {
        const id1 = Math.min(link.source, link.target);
        const id2 = Math.max(link.source, link.target);
        const uniqueId = `${id1}-${id2}`;
        if (!linkSet.has(uniqueId)) {
            link.originalScore = link.score; // Store original score
            uniqueLinks.push(link);
            linkSet.add(uniqueId);
        }
    });

    let graphData = { nodes: archetypes, links: uniqueLinks };
    const highlightNodes = new Set();
    const highlightLinks = new Set();
    let hoverNode = null;

    const Graph = ForceGraph3D()
      (document.getElementById('3d-graph'))
        .graphData(graphData)
        .backgroundColor('#111111') // Darker background

        // Nodes
        .nodeLabel('name')
        // Node size used for physics and label positioning
        .nodeVal(node => node === hoverNode ? 6 : 3.5) // Physics size
        .nodeThreeObject(node => {
            const isHovered = node === hoverNode;
            const nodeSize = node === hoverNode ? 6 : 3.5; // Visual size matches physics size
            const nodeColor = isHovered ? '#ffa500' : '#5ca9f8'; // Orange highlight, blue default

            // Bubble (Sphere)
            const geometry = new THREE.SphereGeometry(nodeSize, 16, 8);
            const material = new THREE.MeshStandardMaterial({
                color: nodeColor,
                metalness: 0.3,
                roughness: 0.4,
                transparent: false, // Ensure sphere is opaque
                opacity: 1.0
            });
            const sphere = new THREE.Mesh(geometry, material);

            // Label (SpriteText)
            const sprite = new SpriteText(node.name.replace(' ', '\n'));
            sprite.material.depthWrite = false; // Keep text visible against distant objects
            sprite.color = isHovered ? '#ffffff' : '#eeeeee'; // White when hovered, bright grey otherwise
            const textHeight = isHovered ? 6 : 4; // Use this for positioning offset estimate
            sprite.textHeight = textHeight;
            // Ensure sprite material is opaque (SpriteText handles this internally usually)
            // sprite.material.transparent = false; // Not needed for SpriteText material
            // sprite.material.opacity = 1.0;

            // Position sprite above sphere
            // Estimate offset: nodeSize + half of textHeight (approx) + small gap
            const yOffset = nodeSize + (textHeight * 0.8) + 1; // Adjust multiplier as needed
            sprite.position.set(0, yOffset, 0);

            // Group sphere and sprite
            const group = new THREE.Group();
            group.add(sphere);
            group.add(sprite);

            return group;
        })
        .nodeThreeObjectExtend(false) // We are returning the complete object (Group), so set extend to false
        .onNodeHover(node => {
            // highlightNodes.clear(); // Not strictly needed anymore if only using hoverNode
            highlightLinks.clear();
            hoverNode = node || null; // Set the currently hovered node

            if (hoverNode) {
                // Populate highlightLinks based on the single hoverNode
                graphData.links.forEach(link => {
                    if (link.source === hoverNode || link.target === hoverNode) {
                        highlightLinks.add(link);
                        // No need to add neighbors to highlightNodes
                    }
                });
            }

            // Trigger graph update to reflect hover changes
            Graph.nodeThreeObject(Graph.nodeThreeObject()) // Update node object (sphere+sprite)
                 .nodeVal(Graph.nodeVal()) // Update node physics size
                 .linkColor(Graph.linkColor()) // Link styles depend on highlightLinks
                 .linkWidth(Graph.linkWidth())
                 .linkDirectionalParticles(Graph.linkDirectionalParticles());
        })

        // Links
        .linkSource('source')
        .linkTarget('target')
        .linkWidth(link => highlightLinks.has(link) ? getLinkStyle(link.originalScore).width * 1.5 : getLinkStyle(link.originalScore).width)
        .linkColor(link => highlightLinks.has(link) ? getLinkStyle(link.originalScore).highlightColor : getLinkStyle(link.originalScore).color)
        .linkOpacity(0.8)
        .linkDirectionalParticles(link => highlightLinks.has(link) && link.originalScore >= 4 ? 2 : (link.originalScore >= 4 ? 1 : 0))
        .linkDirectionalParticleWidth(link => getLinkStyle(link.originalScore).width * (highlightLinks.has(link)? 0.8 : 0.5) )
        .linkDirectionalParticleColor(link => getLinkStyle(link.originalScore).highlightColor);

    // Add lights
    const ambientLight = new THREE.AmbientLight(0xbbbbbb);
    Graph.scene().add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
    directionalLight.position.set(1, 1, 1);
    Graph.scene().add(directionalLight);

    // Function to map score to color and width
    function getLinkStyle(score) {
        let color, width, highlightColor;
        const baseWidth = 0.15;
        const maxWidth = 2.0;

        switch (score) {
            case 5: color = '#ff4500cc'; highlightColor = '#ff4500'; width = maxWidth; break; // Orangered (Hot)
            case 4: color = '#ffac33cc'; highlightColor = '#ffac33'; width = baseWidth + (maxWidth - baseWidth) * 0.7; break; // Orange
            case 3: color = '#ffff66cc'; highlightColor = '#ffff66'; width = baseWidth + (maxWidth - baseWidth) * 0.4; break; // Yellow (Warm)
            case 2: color = '#77b5fecc'; highlightColor = '#77b5fe'; width = baseWidth + (maxWidth - baseWidth) * 0.2; break; // Light Blue
            case 1: color = '#aec6cfcc'; highlightColor = '#aec6cf'; width = baseWidth; break; // LightSteelBlue (Cool)
            default: color = '#66666699'; highlightColor = '#666666'; width = 0.08; break; // Dark Grey for 0 (Very Cool / None)
        }
        return { color: color, highlightColor: highlightColor, width: width };
    }

     // Configure forces
    Graph.d3Force('link').distance(link => {
        const baseDist = 80;
        return baseDist / (link.originalScore + 1);
    });
    Graph.d3Force('charge').strength(-120);
    Graph.d3Force('center').strength(0.05);

    // --- Slider Functionality ---
    const scoreSlider = document.getElementById('scoreSlider');
    const scoreValueSpan = document.getElementById('scoreValue');
    const speedSlider = document.getElementById('speedSlider');
    const speedValueSpan = document.getElementById('speedValue');

    scoreSlider.oninput = function() {
        const minScore = parseInt(this.value);
        scoreValueSpan.textContent = minScore;

        const filteredLinks = uniqueLinks.filter(link => link.originalScore >= minScore);
        graphData = { nodes: archetypes, links: filteredLinks };
        Graph.graphData(graphData);
    }

    speedSlider.oninput = function() {
        const speed = parseFloat(this.value);
        speedValueSpan.textContent = speed.toFixed(1);
        // Update autoRotateSpeed if controls exist
        if (Graph && Graph.controls()) {
            Graph.controls().autoRotateSpeed = speed;
        }
    }

    // Initial filter based on slider default value
    scoreSlider.dispatchEvent(new Event('input'));
    // Initial speed setup
    speedSlider.dispatchEvent(new Event('input'));

     // Auto-focus on the center and enable auto-rotate after initial stabilization
     Graph.onEngineStop(() => {
        Graph.zoomToFit(400);
        const controls = Graph.controls();
        controls.autoRotate = true;
        controls.autoRotateSpeed = parseFloat(speedSlider.value);
     });

</script>

</body>
</html> 